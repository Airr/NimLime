[
  {
    "comment": "The compiler depends on the System module to work properly and the System\u000D\u000A## module depends on the compiler. Most of the routines listed here use\u000D\u000A## special compiler magic.\u000D\u000A## Each module implicitly imports the System module; it must not be listed\u000D\u000A## explicitly. Because of this there cannot be a user-defined module named\u000D\u000A## ``system``."
  }, 
  {
    "name": "float64", 
    "type": "skType", 
    "description": "64 bit floating point type", 
    "code": "float64* {.magic: Float.} "
  }, 
  {
    "name": "bool", 
    "type": "skType", 
    "description": "built-in boolean type", 
    "code": "bool* {.magic: Bool.} = enum \u000D\u000A  false = 0, true = 1"
  }, 
  {
    "name": "pointer", 
    "type": "skType", 
    "description": "built-in pointer type, use the <tt class=\"docutils literal\"><span class=\"pre\">addr</span></tt> operator to get a pointer to a variable", 
    "code": "pointer* {.magic: Pointer.} "
  }, 
  {
    "name": "off", 
    "type": "skConst", 
    "description": "alias for <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt>", 
    "code": "off* = false"
  }, 
  {
    "name": "TNumber", 
    "type": "skType", 
    "description": "type class matching all number types", 
    "code": "TNumber* = TInteger | TReal"
  }, 
  {
    "name": "defined", 
    "type": "skProc", 
    "description": "Special compile-time procedure that checks whether <cite>x</cite> is defined. <cite>x</cite> has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:<pre><span class=\"Keyword\">when</span> <span class=\"Keyword\">not</span> <span class=\"Identifier\">defined</span><span class=\"Punctation\">(</span><span class=\"Identifier\">strutils</span><span class=\"Operator\">.</span><span class=\"Identifier\">toUpper</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span>\u000D\u000A  <span class=\"Comment\"># provide our own toUpper proc here, because strutils is</span>\u000D\u000A  <span class=\"Comment\"># missing it.</span></pre>", 
    "code": "proc defined*(x: expr): bool {.magic: \"Defined\", noSideEffect.}"
  }, 
  {
    "name": "definedInScope", 
    "type": "skProc", 
    "description": "Special compile-time procedure that checks whether <cite>x</cite> is defined in the current scope. <cite>x</cite> has to be an identifier.", 
    "code": "proc definedInScope*(x: expr): bool {.magic: \"DefinedInScope\", noSideEffect.}"
  }, 
  {
    "name": "`not`", 
    "type": "skProc", 
    "description": "Boolean not; returns true iff <tt class=\"docutils literal\"><span class=\"pre\">x == false</span></tt>.", 
    "code": "proc `not`*(x: bool): bool {.magic: \"Not\", noSideEffect.}"
  }, 
  {
    "name": "`and`", 
    "type": "skProc", 
    "description": "Boolean <tt class=\"docutils literal\"><span class=\"pre\">and</span></tt>; returns true iff <tt class=\"docutils literal\"><span class=\"pre\">x == y == true</span></tt>. Evaluation is lazy: if <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> is false, <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt> will not even be evaluated.", 
    "code": "proc `and`*(x, y: bool): bool {.magic: \"And\", noSideEffect.}"
  }, 
  {
    "name": "`or`", 
    "type": "skProc", 
    "description": "Boolean <tt class=\"docutils literal\"><span class=\"pre\">or</span></tt>; returns true iff <tt class=\"docutils literal\"><span class=\"pre\">not (not x and not y)</span></tt>. Evaluation is lazy: if <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> is true, <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt> will not even be evaluated.", 
    "code": "proc `or`*(x, y: bool): bool {.magic: \"Or\", noSideEffect.}"
  }, 
  {
    "name": "`xor`", 
    "type": "skProc", 
    "description": "Boolean <cite>exclusive or</cite>; returns true iff <tt class=\"docutils literal\"><span class=\"pre\">x != y</span></tt>.", 
    "code": "proc `xor`*(x, y: bool): bool {.magic: \"Xor\", noSideEffect.}"
  }, 
  {
    "name": "new", 
    "type": "skProc", 
    "description": "creates a new object of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> and returns a safe (traced) reference to it in <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt>.", 
    "code": "proc new*[T](a: var ref T) {.magic: \"New\", noSideEffect.}"
  }, 
  {
    "name": "new", 
    "type": "skProc", 
    "description": "creates a new object of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> and returns a safe (traced) reference to it as result value", 
    "code": "proc new*(T: typedesc): ref T"
  }, 
  {
    "name": "unsafeNew", 
    "type": "skProc", 
    "description": "creates a new object of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> and returns a safe (traced) reference to it in <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt>. This is <strong>unsafe</strong> as it allocates an object of the passed <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt>. This should only be used for optimization purposes when you know what you're doing!", 
    "code": "proc unsafeNew*[T](a: var ref T; size: int) {.magic: \"New\", noSideEffect.}"
  }, 
  {
    "name": "internalNew", 
    "type": "skProc", 
    "description": "leaked implementation detail. Do not use.", 
    "code": "proc internalNew*[T](a: var ref T) {.magic: \"New\", noSideEffect.}"
  }, 
  {
    "name": "new", 
    "type": "skProc", 
    "description": "creates a new object of type <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> and returns a safe (traced) reference to it in <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt>. When the garbage collector frees the object, <cite>finalizer</cite> is called. The <cite>finalizer</cite> may not keep a reference to the object pointed to by <cite>x</cite>. The <cite>finalizer</cite> cannot prevent the GC from freeing the object. Note: The <cite>finalizer</cite> refers to the type <cite>T</cite>, not to the object! This means that for each object of type <cite>T</cite> the finalizer will be called!", 
    "code": "proc new*[T](a: var ref T; finalizer: proc (x: ref T) {.nimcall.}) {.\u000D\u000A    magic: \"NewFinalize\", noSideEffect.}"
  }, 
  {
    "name": "reset", 
    "type": "skProc", 
    "description": "resets an object <cite>obj</cite> to its initial (binary zero) value. This needs to be called before any possible <span id=\"object-branch-transition_1397973209\">object branch transition</span>.", 
    "code": "proc reset*[T](obj: var T) {.magic: \"Reset\", noSideEffect.}"
  }, 
  {
    "name": "high", 
    "type": "skProc", 
    "description": "returns the highest possible index of an array, a sequence, a string or the highest possible value of an ordinal value <cite>x</cite>. As a special semantic rule, <cite>x</cite> may also be a type identifier.", 
    "code": "proc high*[T](x: T): T {.magic: \"High\", noSideEffect.}"
  }, 
  {
    "name": "low", 
    "type": "skProc", 
    "description": "returns the lowest possible index of an array, a sequence, a string or the lowest possible value of an ordinal value <cite>x</cite>. As a special semantic rule, <cite>x</cite> may also be a type identifier.", 
    "code": "proc low*[T](x: T): T {.magic: \"Low\", noSideEffect.}"
  }, 
  {
    "name": "set", 
    "type": "skType", 
    "description": "Generic type to construct bit sets.", 
    "code": "set* {.magic: \"Set\".}[T] "
  }, 
  {
    "name": "TSlice", 
    "type": "skType", 
    "description": "builtin slice type", 
    "code": "TSlice* {.final, pure.}[T] = object \u000D\u000A  a*, b*: T                   ## the bounds\u000D\u000A  "
  }, 
  {
    "name": "`..`", 
    "type": "skProc", 
    "description": "<span id=\"slice_1296247024\">slice</span> operator that constructs an interval <tt class=\"docutils literal\"><span class=\"pre\">[a, b]</span></tt>, both <cite>a</cite> and <cite>b</cite> are inclusive. Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler.", 
    "code": "proc `..`*[T](a, b: T): TSlice[T] {.noSideEffect, inline.}"
  }, 
  {
    "name": "`..`", 
    "type": "skProc", 
    "description": "<span id=\"slice_1296247024\">slice</span> operator that constructs an interval <tt class=\"docutils literal\"><span class=\"pre\">[default(T), b]</span></tt>", 
    "code": "proc `..`*[T](b: T): TSlice[T] {.noSideEffect, inline.}"
  }, 
  {
    "name": "TResult", 
    "type": "skType", 
    "code": "TResult* = enum \u000D\u000A  Failure, Success"
  }, 
  {
    "name": "sizeof", 
    "type": "skProc", 
    "description": "returns the size of <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> in bytes. Since this is a low-level proc, its usage is discouraged - using <tt class=\"docutils literal\"><span class=\"pre\">new</span></tt> for the most cases suffices that one never needs to know <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>'s size. As a special semantic rule, <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> may also be a type identifier (<tt class=\"docutils literal\"><span class=\"pre\">sizeof(int)</span></tt> is valid).", 
    "code": "proc sizeof*[T](x: T): natural {.magic: \"SizeOf\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "description": "unary <tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> that can be used for nice looking excluding ranges:<pre><span class=\"Keyword\">for</span> <span class=\"Identifier\">i</span> <span class=\"Keyword\">in</span> <span class=\"DecNumber\">0</span> <span class=\"Operator\">..</span> <span class=\"Operator\">&lt;</span><span class=\"DecNumber\">10</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">echo</span> <span class=\"Identifier\">i</span></pre><p>Semantically this is the same as <tt class=\"docutils literal\"><span class=\"pre\">pred</span></tt>. </p>\u000D\u000A", 
    "code": "proc `<`*[T](x: ordinal[T]): T {.magic: \"UnaryLt\", noSideEffect.}"
  }, 
  {
    "name": "succ", 
    "type": "skProc", 
    "description": "returns the <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt>-th successor of the value <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> has to be an ordinal type. If such a value does not exist, <tt class=\"docutils literal\"><span class=\"pre\">EOutOfRange</span></tt> is raised or a compile time error occurs.", 
    "code": "proc succ*[T](x: ordinal[T]; y = 1): T {.magic: \"Succ\", noSideEffect.}"
  }, 
  {
    "name": "pred", 
    "type": "skProc", 
    "description": "returns the <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt>-th predecessor of the value <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> has to be an ordinal type. If such a value does not exist, <tt class=\"docutils literal\"><span class=\"pre\">EOutOfRange</span></tt> is raised or a compile time error occurs.", 
    "code": "proc pred*[T](x: ordinal[T]; y = 1): T {.magic: \"Pred\", noSideEffect.}"
  }, 
  {
    "name": "inc", 
    "type": "skProc", 
    "description": "increments the ordinal <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> by <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt>. If such a value does not exist, <tt class=\"docutils literal\"><span class=\"pre\">EOutOfRange</span></tt> is raised or a compile time error occurs. This is a short notation for: <tt class=\"docutils literal\"><span class=\"pre\">x = succ(x, y)</span></tt>.", 
    "code": "proc inc*[T](x: var ordinal[T]; y = 1) {.magic: \"Inc\", noSideEffect.}"
  }, 
  {
    "name": "dec", 
    "type": "skProc", 
    "description": "decrements the ordinal <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> by <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt>. If such a value does not exist, <tt class=\"docutils literal\"><span class=\"pre\">EOutOfRange</span></tt> is raised or a compile time error occurs. This is a short notation for: <tt class=\"docutils literal\"><span class=\"pre\">x = pred(x, y)</span></tt>.", 
    "code": "proc dec*[T](x: var ordinal[T]; y = 1) {.magic: \"Dec\", noSideEffect.}"
  }, 
  {
    "name": "newSeq", 
    "type": "skProc", 
    "description": "<p>creates a new sequence of type <tt class=\"docutils literal\"><span class=\"pre\">seq[T]</span></tt> with length <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt>. This is equivalent to <tt class=\"docutils literal\"><span class=\"pre\">s = @[]; setlen(s, len)</span></tt>, but more efficient since no reallocation is needed.</p>\u000D\u000A<p>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</p>\u000D\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">inputStrings</span> <span class=\"Punctation\">:</span> <span class=\"Identifier\">seq</span><span class=\"Punctation\">[</span><span class=\"Identifier\">string</span><span class=\"Punctation\">]</span>\u000D\u000A<span class=\"Identifier\">newSeq</span><span class=\"Punctation\">(</span><span class=\"Identifier\">inputStrings</span><span class=\"Punctation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctation\">)</span>\u000D\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;The fourth&quot;</span>\u000D\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;assignment&quot;</span>\u000D\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;would crash&quot;</span>\u000D\u000A<span class=\"Comment\">#inputStrings[3] = &quot;out of bounds&quot;</span></pre>", 
    "code": "proc newSeq*[T](s: var seq[T]; len: int) {.magic: \"NewSeq\", noSideEffect.}"
  }, 
  {
    "name": "newSeq", 
    "type": "skProc", 
    "description": "<p>creates a new sequence of type <tt class=\"docutils literal\"><span class=\"pre\">seq[T]</span></tt> with length <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt>.</p>\u000D\u000A<p>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</p>\u000D\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">inputStrings</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">newSeq</span><span class=\"Punctation\">[</span><span class=\"Identifier\">string</span><span class=\"Punctation\">]</span><span class=\"Punctation\">(</span><span class=\"DecNumber\">3</span><span class=\"Punctation\">)</span>\u000D\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">0</span><span class=\"Punctation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;The fourth&quot;</span>\u000D\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;assignment&quot;</span>\u000D\u000A<span class=\"Identifier\">inputStrings</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">2</span><span class=\"Punctation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;would crash&quot;</span>\u000D\u000A<span class=\"Comment\">#inputStrings[3] = &quot;out of bounds&quot;</span></pre>", 
    "code": "proc newSeq*[T](len = 0): seq[T]"
  }, 
  {
    "name": "len", 
    "type": "skProc", 
    "code": "proc len*[TOpenArray: openArray | varargs](x: TOpenArray): int {.\u000D\u000A    magic: \"LengthOpenArray\", noSideEffect.}"
  }, 
  {
    "name": "len", 
    "type": "skProc", 
    "code": "proc len*(x: string): int {.magic: \"LengthStr\", noSideEffect.}"
  }, 
  {
    "name": "len", 
    "type": "skProc", 
    "code": "proc len*(x: cstring): int {.magic: \"LengthStr\", noSideEffect.}"
  }, 
  {
    "name": "len", 
    "type": "skProc", 
    "code": "proc len*[I, T](x: array[I, T]): int {.magic: \"LengthArray\", noSideEffect.}"
  }, 
  {
    "name": "len", 
    "type": "skProc", 
    "description": "returns the length of an array, an openarray, a sequence or a string. This is rougly the same as <tt class=\"docutils literal\"><span class=\"pre\">high(T)-low(T)+1</span></tt>, but its resulting type is always an int.", 
    "code": "proc len*[T](x: seq[T]): int {.magic: \"LengthSeq\", noSideEffect.}"
  }, 
  {
    "name": "incl", 
    "type": "skProc", 
    "description": "includes element <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt> to the set <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">x = x + {y}</span></tt>, but it might be more efficient.", 
    "code": "proc incl*[T](x: var set[T]; y: T) {.magic: \"Incl\", noSideEffect.}"
  }, 
  {
    "name": "excl", 
    "type": "skProc", 
    "description": "excludes element <tt class=\"docutils literal\"><span class=\"pre\">y</span></tt> to the set <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">x = x - {y}</span></tt>, but it might be more efficient.", 
    "code": "proc excl*[T](x: var set[T]; y: T) {.magic: \"Excl\", noSideEffect.}"
  }, 
  {
    "name": "card", 
    "type": "skProc", 
    "description": "returns the cardinality of the set <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>, i.e. the number of elements in the set.", 
    "code": "proc card*[T](x: set[T]): int {.magic: \"Card\", noSideEffect.}"
  }, 
  {
    "name": "ord", 
    "type": "skProc", 
    "description": "returns the internal int value of an ordinal value <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt>.", 
    "code": "proc ord*[T](x: T): int {.magic: \"Ord\", noSideEffect.}"
  }, 
  {
    "name": "chr", 
    "type": "skProc", 
    "description": "converts an int in the range 0..255 to a character.", 
    "code": "proc chr*(u: range[0 .. 255]): char {.magic: \"Chr\", noSideEffect.}"
  }, 
  {
    "name": "ze", 
    "type": "skProc", 
    "description": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int</span></tt>. This treats <cite>x</cite> as unsigned.", 
    "code": "proc ze*(x: int8): int {.magic: \"Ze8ToI\", noSideEffect.}"
  }, 
  {
    "name": "ze", 
    "type": "skProc", 
    "description": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int</span></tt>. This treats <cite>x</cite> as unsigned.", 
    "code": "proc ze*(x: int16): int {.magic: \"Ze16ToI\", noSideEffect.}"
  }, 
  {
    "name": "ze64", 
    "type": "skProc", 
    "description": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. This treats <cite>x</cite> as unsigned.", 
    "code": "proc ze64*(x: int8): int64 {.magic: \"Ze8ToI64\", noSideEffect.}"
  }, 
  {
    "name": "ze64", 
    "type": "skProc", 
    "description": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. This treats <cite>x</cite> as unsigned.", 
    "code": "proc ze64*(x: int16): int64 {.magic: \"Ze16ToI64\", noSideEffect.}"
  }, 
  {
    "name": "ze64", 
    "type": "skProc", 
    "description": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. This treats <cite>x</cite> as unsigned.", 
    "code": "proc ze64*(x: int32): int64 {.magic: \"Ze32ToI64\", noSideEffect.}"
  }, 
  {
    "name": "ze64", 
    "type": "skProc", 
    "description": "zero extends a smaller integer type to <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. This treats <cite>x</cite> as unsigned. Does nothing if the size of an <tt class=\"docutils literal\"><span class=\"pre\">int</span></tt> is the same as <tt class=\"docutils literal\"><span class=\"pre\">int64</span></tt>. (This is the case on 64 bit processors.)", 
    "code": "proc ze64*(x: int): int64 {.magic: \"ZeIToI64\", noSideEffect.}"
  }, 
  {
    "name": "toU8", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> as unsigned and converts it to a byte by taking the last 8 bits from <cite>x</cite>.", 
    "code": "proc toU8*(x: int): int8 {.magic: \"ToU8\", noSideEffect.}"
  }, 
  {
    "name": "toU16", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> as unsigned and converts it to an <tt class=\"docutils literal\"><span class=\"pre\">int16</span></tt> by taking the last 16 bits from <cite>x</cite>.", 
    "code": "proc toU16*(x: int): int16 {.magic: \"ToU16\", noSideEffect.}"
  }, 
  {
    "name": "toU32", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> as unsigned and converts it to an <tt class=\"docutils literal\"><span class=\"pre\">int32</span></tt> by taking the last 32 bits from <cite>x</cite>.", 
    "code": "proc toU32*(x: int64): int32 {.magic: \"ToU32\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x: int): int {.magic: \"UnaryPlusI\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x: int8): int8 {.magic: \"UnaryPlusI\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x: int16): int16 {.magic: \"UnaryPlusI\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x: int32): int32 {.magic: \"UnaryPlusI\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "description": "Unary <cite>+</cite> operator for an integer. Has no effect.", 
    "code": "proc `+`*(x: int64): int64 {.magic: \"UnaryPlusI64\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x: int): int {.magic: \"UnaryMinusI\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x: int8): int8 {.magic: \"UnaryMinusI\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x: int16): int16 {.magic: \"UnaryMinusI\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x: int32): int32 {.magic: \"UnaryMinusI\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "description": "Unary <cite>-</cite> operator for an integer. Negates <cite>x</cite>.", 
    "code": "proc `-`*(x: int64): int64 {.magic: \"UnaryMinusI64\", noSideEffect.}"
  }, 
  {
    "name": "`not`", 
    "type": "skProc", 
    "code": "proc `not`*(x: int): int {.magic: \"BitnotI\", noSideEffect.}"
  }, 
  {
    "name": "`not`", 
    "type": "skProc", 
    "code": "proc `not`*(x: int8): int8 {.magic: \"BitnotI\", noSideEffect.}"
  }, 
  {
    "name": "`not`", 
    "type": "skProc", 
    "code": "proc `not`*(x: int16): int16 {.magic: \"BitnotI\", noSideEffect.}"
  }, 
  {
    "name": "`not`", 
    "type": "skProc", 
    "code": "proc `not`*(x: int32): int32 {.magic: \"BitnotI\", noSideEffect.}"
  }, 
  {
    "name": "`not`", 
    "type": "skProc", 
    "description": "computes the <cite>bitwise complement</cite> of the integer <cite>x</cite>.", 
    "code": "proc `not`*(x: int64): int64 {.magic: \"BitnotI64\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x, y: int): int {.magic: \"AddI\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x, y: int8): int8 {.magic: \"AddI\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x, y: int16): int16 {.magic: \"AddI\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x, y: int32): int32 {.magic: \"AddI\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "description": "Binary <cite>+</cite> operator for an integer.", 
    "code": "proc `+`*(x, y: int64): int64 {.magic: \"AddI64\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x, y: int): int {.magic: \"SubI\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x, y: int8): int8 {.magic: \"SubI\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x, y: int16): int16 {.magic: \"SubI\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x, y: int32): int32 {.magic: \"SubI\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "description": "Binary <cite>-</cite> operator for an integer.", 
    "code": "proc `-`*(x, y: int64): int64 {.magic: \"SubI64\", noSideEffect.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "code": "proc `*`*(x, y: int): int {.magic: \"MulI\", noSideEffect.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "code": "proc `*`*(x, y: int8): int8 {.magic: \"MulI\", noSideEffect.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "code": "proc `*`*(x, y: int16): int16 {.magic: \"MulI\", noSideEffect.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "code": "proc `*`*(x, y: int32): int32 {.magic: \"MulI\", noSideEffect.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "description": "Binary <cite>*</cite> operator for an integer.", 
    "code": "proc `*`*(x, y: int64): int64 {.magic: \"MulI64\", noSideEffect.}"
  }, 
  {
    "name": "`div`", 
    "type": "skProc", 
    "code": "proc `div`*(x, y: int): int {.magic: \"DivI\", noSideEffect.}"
  }, 
  {
    "name": "`div`", 
    "type": "skProc", 
    "code": "proc `div`*(x, y: int8): int8 {.magic: \"DivI\", noSideEffect.}"
  }, 
  {
    "name": "`div`", 
    "type": "skProc", 
    "code": "proc `div`*(x, y: int16): int16 {.magic: \"DivI\", noSideEffect.}"
  }, 
  {
    "name": "`div`", 
    "type": "skProc", 
    "code": "proc `div`*(x, y: int32): int32 {.magic: \"DivI\", noSideEffect.}"
  }, 
  {
    "name": "`div`", 
    "type": "skProc", 
    "description": "computes the integer division. This is roughly the same as <tt class=\"docutils literal\"><span class=\"pre\">floor(x/y)</span></tt>.", 
    "code": "proc `div`*(x, y: int64): int64 {.magic: \"DivI64\", noSideEffect.}"
  }, 
  {
    "name": "`mod`", 
    "type": "skProc", 
    "code": "proc `mod`*(x, y: int): int {.magic: \"ModI\", noSideEffect.}"
  }, 
  {
    "name": "`mod`", 
    "type": "skProc", 
    "code": "proc `mod`*(x, y: int8): int8 {.magic: \"ModI\", noSideEffect.}"
  }, 
  {
    "name": "`mod`", 
    "type": "skProc", 
    "code": "proc `mod`*(x, y: int16): int16 {.magic: \"ModI\", noSideEffect.}"
  }, 
  {
    "name": "`mod`", 
    "type": "skProc", 
    "code": "proc `mod`*(x, y: int32): int32 {.magic: \"ModI\", noSideEffect.}"
  }, 
  {
    "name": "`mod`", 
    "type": "skProc", 
    "description": "computes the integer modulo operation. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">x - (x div y) * y</span></tt>.", 
    "code": "proc `mod`*(x, y: int64): int64 {.magic: \"ModI64\", noSideEffect.}"
  }, 
  {
    "name": "`shr`", 
    "type": "skProc", 
    "code": "proc `shr`*(x, y: int): int {.magic: \"ShrI\", noSideEffect.}"
  }, 
  {
    "name": "`shr`", 
    "type": "skProc", 
    "code": "proc `shr`*(x, y: int8): int8 {.magic: \"ShrI\", noSideEffect.}"
  }, 
  {
    "name": "`shr`", 
    "type": "skProc", 
    "code": "proc `shr`*(x, y: int16): int16 {.magic: \"ShrI\", noSideEffect.}"
  }, 
  {
    "name": "`shr`", 
    "type": "skProc", 
    "code": "proc `shr`*(x, y: int32): int32 {.magic: \"ShrI\", noSideEffect.}"
  }, 
  {
    "name": "`shr`", 
    "type": "skProc", 
    "description": "computes the <cite>shift right</cite> operation of <cite>x</cite> and <cite>y</cite>.", 
    "code": "proc `shr`*(x, y: int64): int64 {.magic: \"ShrI64\", noSideEffect.}"
  }, 
  {
    "name": "`shl`", 
    "type": "skProc", 
    "code": "proc `shl`*(x, y: int): int {.magic: \"ShlI\", noSideEffect.}"
  }, 
  {
    "name": "`shl`", 
    "type": "skProc", 
    "code": "proc `shl`*(x, y: int8): int8 {.magic: \"ShlI\", noSideEffect.}"
  }, 
  {
    "name": "`shl`", 
    "type": "skProc", 
    "code": "proc `shl`*(x, y: int16): int16 {.magic: \"ShlI\", noSideEffect.}"
  }, 
  {
    "name": "`shl`", 
    "type": "skProc", 
    "code": "proc `shl`*(x, y: int32): int32 {.magic: \"ShlI\", noSideEffect.}"
  }, 
  {
    "name": "`shl`", 
    "type": "skProc", 
    "description": "computes the <cite>shift left</cite> operation of <cite>x</cite> and <cite>y</cite>.", 
    "code": "proc `shl`*(x, y: int64): int64 {.magic: \"ShlI64\", noSideEffect.}"
  }, 
  {
    "name": "`and`", 
    "type": "skProc", 
    "code": "proc `and`*(x, y: int): int {.magic: \"BitandI\", noSideEffect.}"
  }, 
  {
    "name": "`and`", 
    "type": "skProc", 
    "code": "proc `and`*(x, y: int8): int8 {.magic: \"BitandI\", noSideEffect.}"
  }, 
  {
    "name": "`and`", 
    "type": "skProc", 
    "code": "proc `and`*(x, y: int16): int16 {.magic: \"BitandI\", noSideEffect.}"
  }, 
  {
    "name": "`and`", 
    "type": "skProc", 
    "code": "proc `and`*(x, y: int32): int32 {.magic: \"BitandI\", noSideEffect.}"
  }, 
  {
    "name": "`and`", 
    "type": "skProc", 
    "description": "computes the <cite>bitwise and</cite> of numbers <cite>x</cite> and <cite>y</cite>.", 
    "code": "proc `and`*(x, y: int64): int64 {.magic: \"BitandI64\", noSideEffect.}"
  }, 
  {
    "name": "`or`", 
    "type": "skProc", 
    "code": "proc `or`*(x, y: int): int {.magic: \"BitorI\", noSideEffect.}"
  }, 
  {
    "name": "`or`", 
    "type": "skProc", 
    "code": "proc `or`*(x, y: int8): int8 {.magic: \"BitorI\", noSideEffect.}"
  }, 
  {
    "name": "`or`", 
    "type": "skProc", 
    "code": "proc `or`*(x, y: int16): int16 {.magic: \"BitorI\", noSideEffect.}"
  }, 
  {
    "name": "`or`", 
    "type": "skProc", 
    "code": "proc `or`*(x, y: int32): int32 {.magic: \"BitorI\", noSideEffect.}"
  }, 
  {
    "name": "`or`", 
    "type": "skProc", 
    "description": "computes the <cite>bitwise or</cite> of numbers <cite>x</cite> and <cite>y</cite>.", 
    "code": "proc `or`*(x, y: int64): int64 {.magic: \"BitorI64\", noSideEffect.}"
  }, 
  {
    "name": "`xor`", 
    "type": "skProc", 
    "code": "proc `xor`*(x, y: int): int {.magic: \"BitxorI\", noSideEffect.}"
  }, 
  {
    "name": "`xor`", 
    "type": "skProc", 
    "code": "proc `xor`*(x, y: int8): int8 {.magic: \"BitxorI\", noSideEffect.}"
  }, 
  {
    "name": "`xor`", 
    "type": "skProc", 
    "code": "proc `xor`*(x, y: int16): int16 {.magic: \"BitxorI\", noSideEffect.}"
  }, 
  {
    "name": "`xor`", 
    "type": "skProc", 
    "code": "proc `xor`*(x, y: int32): int32 {.magic: \"BitxorI\", noSideEffect.}"
  }, 
  {
    "name": "`xor`", 
    "type": "skProc", 
    "description": "computes the <cite>bitwise xor</cite> of numbers <cite>x</cite> and <cite>y</cite>.", 
    "code": "proc `xor`*(x, y: int64): int64 {.magic: \"BitxorI64\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: int): bool {.magic: \"EqI\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: int8): bool {.magic: \"EqI\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: int16): bool {.magic: \"EqI\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: int32): bool {.magic: \"EqI\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "description": "Compares two integers for equality.", 
    "code": "proc `==`*(x, y: int64): bool {.magic: \"EqI64\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: int): bool {.magic: \"LeI\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: int8): bool {.magic: \"LeI\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: int16): bool {.magic: \"LeI\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: int32): bool {.magic: \"LeI\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "description": "Returns true iff <cite>x</cite> is less than or equal to <cite>y</cite>.", 
    "code": "proc `<=`*(x, y: int64): bool {.magic: \"LeI64\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: int): bool {.magic: \"LtI\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: int8): bool {.magic: \"LtI\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: int16): bool {.magic: \"LtI\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: int32): bool {.magic: \"LtI\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "description": "Returns true iff <cite>x</cite> is less than <cite>y</cite>.", 
    "code": "proc `<`*(x, y: int64): bool {.magic: \"LtI64\", noSideEffect.}"
  }, 
  {
    "name": "`+%`", 
    "type": "skProc", 
    "code": "proc `+%`*(x, y: IntMax32): IntMax32 {.magic: \"AddU\", noSideEffect.}"
  }, 
  {
    "name": "`+%`", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and adds them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.", 
    "code": "proc `+%`*(x, y: Int64): Int64 {.magic: \"AddU\", noSideEffect.}"
  }, 
  {
    "name": "`-%`", 
    "type": "skProc", 
    "code": "proc `-%`*(x, y: IntMax32): IntMax32 {.magic: \"SubU\", noSideEffect.}"
  }, 
  {
    "name": "`-%`", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and subtracts them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.", 
    "code": "proc `-%`*(x, y: Int64): Int64 {.magic: \"SubU\", noSideEffect.}"
  }, 
  {
    "name": "`*%`", 
    "type": "skProc", 
    "code": "proc `*%`*(x, y: IntMax32): IntMax32 {.magic: \"MulU\", noSideEffect.}"
  }, 
  {
    "name": "`*%`", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and multiplies them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.", 
    "code": "proc `*%`*(x, y: Int64): Int64 {.magic: \"MulU\", noSideEffect.}"
  }, 
  {
    "name": "`/%`", 
    "type": "skProc", 
    "code": "proc `/%`*(x, y: IntMax32): IntMax32 {.magic: \"DivU\", noSideEffect.}"
  }, 
  {
    "name": "`/%`", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and divides them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.", 
    "code": "proc `/%`*(x, y: Int64): Int64 {.magic: \"DivU\", noSideEffect.}"
  }, 
  {
    "name": "`%%`", 
    "type": "skProc", 
    "code": "proc `%%`*(x, y: IntMax32): IntMax32 {.magic: \"ModU\", noSideEffect.}"
  }, 
  {
    "name": "`%%`", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compute the modulo of <cite>x</cite> and <cite>y</cite>. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.", 
    "code": "proc `%%`*(x, y: Int64): Int64 {.magic: \"ModU\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=%`", 
    "type": "skProc", 
    "code": "proc `<=%`*(x, y: IntMax32): bool {.magic: \"LeU\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=%`", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compares them. Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &lt;= unsigned(y)</span></tt>.", 
    "code": "proc `<=%`*(x, y: Int64): bool {.magic: \"LeU64\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;%`", 
    "type": "skProc", 
    "code": "proc `<%`*(x, y: IntMax32): bool {.magic: \"LtU\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;%`", 
    "type": "skProc", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compares them. Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &lt; unsigned(y)</span></tt>.", 
    "code": "proc `<%`*(x, y: Int64): bool {.magic: \"LtU64\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x: float32): float32 {.magic: \"UnaryPlusF64\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x: float32): float32 {.magic: \"UnaryMinusF64\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x, y: float32): float32 {.magic: \"AddF64\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x, y: float32): float32 {.magic: \"SubF64\", noSideEffect.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "code": "proc `*`*(x, y: float32): float32 {.magic: \"MulF64\", noSideEffect.}"
  }, 
  {
    "name": "`/`", 
    "type": "skProc", 
    "code": "proc `/`*(x, y: float32): float32 {.magic: \"DivF64\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x: float): float {.magic: \"UnaryPlusF64\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x: float): float {.magic: \"UnaryMinusF64\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "code": "proc `+`*(x, y: float): float {.magic: \"AddF64\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "code": "proc `-`*(x, y: float): float {.magic: \"SubF64\", noSideEffect.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "code": "proc `*`*(x, y: float): float {.magic: \"MulF64\", noSideEffect.}"
  }, 
  {
    "name": "`/`", 
    "type": "skProc", 
    "description": "computes the floating point division", 
    "code": "proc `/`*(x, y: float): float {.magic: \"DivF64\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: float32): bool {.magic: \"EqF64\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: float32): bool {.magic: \"LeF64\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: float32): bool {.magic: \"LtF64\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: float): bool {.magic: \"EqF64\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: float): bool {.magic: \"LeF64\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: float): bool {.magic: \"LtF64\", noSideEffect.}"
  }, 
  {
    "name": "`*`", 
    "type": "skProc", 
    "description": "This operator computes the intersection of two sets.", 
    "code": "proc `*`*[T](x, y: set[T]): set[T] {.magic: \"MulSet\", noSideEffect.}"
  }, 
  {
    "name": "`+`", 
    "type": "skProc", 
    "description": "This operator computes the union of two sets.", 
    "code": "proc `+`*[T](x, y: set[T]): set[T] {.magic: \"PlusSet\", noSideEffect.}"
  }, 
  {
    "name": "`-`", 
    "type": "skProc", 
    "description": "This operator computes the difference of two sets.", 
    "code": "proc `-`*[T](x, y: set[T]): set[T] {.magic: \"MinusSet\", noSideEffect.}"
  }, 
  {
    "name": "`-+-`", 
    "type": "skProc", 
    "description": "computes the symmetric set difference. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">(A - B) + (B - A)</span></tt>, but more efficient.", 
    "code": "proc `-+-`*[T](x, y: set[T]): set[T] {.magic: \"SymDiffSet\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*[TEnum: enum](x, y: TEnum): bool {.magic: \"EqEnum\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: pointer): bool {.magic: \"EqRef\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: string): bool {.magic: \"EqStr\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: cstring): bool {.magic: \"EqCString\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: char): bool {.magic: \"EqCh\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*(x, y: bool): bool {.magic: \"EqB\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*[T](x, y: set[T]): bool {.magic: \"EqSet\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*[T](x, y: ref T): bool {.magic: \"EqRef\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*[T](x, y: ptr T): bool {.magic: \"EqRef\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*[T: proc](x, y: T): bool {.magic: \"EqProc\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*[TEnum: enum](x, y: TEnum): bool {.magic: \"LeEnum\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: string): bool {.magic: \"LeStr\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: char): bool {.magic: \"LeCh\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*[T](x, y: set[T]): bool {.magic: \"LeSet\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: bool): bool {.magic: \"LeB\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*[T](x, y: ref T): bool {.magic: \"LePtr\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "code": "proc `<=`*(x, y: pointer): bool {.magic: \"LePtr\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*[TEnum: enum](x, y: TEnum): bool {.magic: \"LtEnum\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: string): bool {.magic: \"LtStr\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: char): bool {.magic: \"LtCh\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*[T](x, y: set[T]): bool {.magic: \"LtSet\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: bool): bool {.magic: \"LtB\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*[T](x, y: ref T): bool {.magic: \"LtPtr\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*[T](x, y: ptr T): bool {.magic: \"LtPtr\", noSideEffect.}"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "code": "proc `<`*(x, y: pointer): bool {.magic: \"LtPtr\", noSideEffect.}"
  }, 
  {
    "name": "`!=`", 
    "type": "skTemplate", 
    "description": "unequals operator. This is a shorthand for <tt class=\"docutils literal\"><span class=\"pre\">not (x == y)</span></tt>.", 
    "code": "template `!=`*(x, y: expr): expr {.immediate.}"
  }, 
  {
    "name": "`&gt;=`", 
    "type": "skTemplate", 
    "description": "&quot;is greater or equals&quot; operator. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">y &lt;= x</span></tt>.", 
    "code": "template `>=`*(x, y: expr): expr {.immediate.}"
  }, 
  {
    "name": "`&gt;`", 
    "type": "skTemplate", 
    "description": "&quot;is greater&quot; operator. This is the same as <tt class=\"docutils literal\"><span class=\"pre\">y &lt; x</span></tt>.", 
    "code": "template `>`*(x, y: expr): expr {.immediate.}"
  }, 
  {
    "name": "contains", 
    "type": "skProc", 
    "description": "One should overload this proc if one wants to overload the <tt class=\"docutils literal\"><span class=\"pre\">in</span></tt> operator. The parameters are in reverse order! <tt class=\"docutils literal\"><span class=\"pre\">a in b</span></tt> is a template for <tt class=\"docutils literal\"><span class=\"pre\">contains(b, a)</span></tt>. This is because the unification algorithm that Nimrod uses for overload resolution works from left to right. But for the <tt class=\"docutils literal\"><span class=\"pre\">in</span></tt> operator that would be the wrong direction for this piece of code:<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">s</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">set</span><span class=\"Punctation\">[</span><span class=\"Identifier\">range</span><span class=\"Punctation\">[</span><span class=\"CharLit\">'a'</span><span class=\"Operator\">..</span><span class=\"CharLit\">'z'</span><span class=\"Punctation\">]</span><span class=\"Punctation\">]</span> <span class=\"Operator\">=</span> <span class=\"Punctation\">{</span><span class=\"CharLit\">'a'</span><span class=\"Operator\">..</span><span class=\"CharLit\">'c'</span><span class=\"Punctation\">}</span>\u000D\u000A<span class=\"Identifier\">writeln</span><span class=\"Punctation\">(</span><span class=\"Identifier\">stdout</span><span class=\"Punctation\">,</span> <span class=\"CharLit\">'b'</span> <span class=\"Keyword\">in</span> <span class=\"Identifier\">s</span><span class=\"Punctation\">)</span></pre><p>If <tt class=\"docutils literal\"><span class=\"pre\">in</span></tt> had been declared as <tt class=\"docutils literal\"><span class=\"pre\">[T](elem: T, s: set[T])</span></tt> then <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> would have been bound to <tt class=\"docutils literal\"><span class=\"pre\">char</span></tt>. But <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> is not compatible to type <tt class=\"docutils literal\"><span class=\"pre\">set[char]</span></tt>! The solution is to bind <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> to <tt class=\"docutils literal\"><span class=\"pre\">range['a'..'z']</span></tt>. This is achieved by reversing the parameters for <tt class=\"docutils literal\"><span class=\"pre\">contains</span></tt>; <tt class=\"docutils literal\"><span class=\"pre\">in</span></tt> then passes its arguments in reverse order.</p>\u000D\u000A", 
    "code": "proc contains*[T](x: set[T]; y: T): bool {.magic: \"InSet\", noSideEffect.}"
  }, 
  {
    "name": "contains", 
    "type": "skProc", 
    "code": "proc contains*[T](s: TSlice[T]; value: T): bool {.noSideEffect, inline.}"
  }, 
  {
    "name": "`in`", 
    "type": "skTemplate", 
    "code": "template `in`*(x, y: expr): expr {.immediate.}"
  }, 
  {
    "name": "`not_in`", 
    "type": "skTemplate", 
    "code": "template `not_in`*(x, y: expr): expr {.immediate.}"
  }, 
  {
    "name": "`is`", 
    "type": "skProc", 
    "code": "proc `is`*[T, S](x: T; y: S): bool {.magic: \"Is\", noSideEffect.}"
  }, 
  {
    "name": "`is_not`", 
    "type": "skTemplate", 
    "code": "template `is_not`*(x, y: expr): expr {.immediate.}"
  }, 
  {
    "name": "`of`", 
    "type": "skProc", 
    "code": "proc `of`*[T, S](x: T; y: S): bool {.magic: \"Of\", noSideEffect.}"
  }, 
  {
    "name": "cmp", 
    "type": "skProc", 
    "description": "Generic compare proc. Returns a value &lt; 0 iff x &lt; y, a value &gt; 0 iff x &gt; y and 0 iff x == y. This is useful for writing generic algorithms without performance loss. This generic implementation uses the <cite>==</cite> and <cite>&lt;</cite> operators.", 
    "code": "proc cmp*[T](x, y: T): int {.procvar.}"
  }, 
  {
    "name": "cmp", 
    "type": "skProc", 
    "description": "Compare proc for strings. More efficient than the generic version.", 
    "code": "proc cmp*(x, y: string): int {.noSideEffect, procvar.}"
  }, 
  {
    "name": "`@`", 
    "type": "skProc", 
    "description": "turns an array into a sequence. This most often useful for constructing sequences with the array constructor: <tt class=\"docutils literal\"><span class=\"pre\">@[1, 2, 3]</span></tt> has the type <tt class=\"docutils literal\"><span class=\"pre\">seq[int]</span></tt>, while <tt class=\"docutils literal\"><span class=\"pre\">[1, 2, 3]</span></tt> has the type <tt class=\"docutils literal\"><span class=\"pre\">array[0..2, int]</span></tt>.", 
    "code": "proc `@`*[IDX, T](a: array[IDX, T]): seq[T] {.magic: \"ArrToSeq\", nosideeffect.}"
  }, 
  {
    "name": "setLen", 
    "type": "skProc", 
    "description": "sets the length of <cite>s</cite> to <cite>newlen</cite>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> may be any sequence type. If the current length is greater than the new length, <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> will be truncated. <cite>s</cite> cannot be nil! To initialize a sequence with a size, use <tt class=\"docutils literal\"><span class=\"pre\">newSeq</span></tt> instead. ", 
    "code": "proc setLen*[T](s: var seq[T]; newlen: int) {.magic: \"SetLengthSeq\", \u000D\u000A    noSideEffect.}"
  }, 
  {
    "name": "setLen", 
    "type": "skProc", 
    "description": "sets the length of <cite>s</cite> to <cite>newlen</cite>. If the current length is greater than the new length, <tt class=\"docutils literal\"><span class=\"pre\">s</span></tt> will be truncated. <cite>s</cite> cannot be nil! To initialize a string with a size, use <tt class=\"docutils literal\"><span class=\"pre\">newString</span></tt> instead. ", 
    "code": "proc setLen*(s: var string; newlen: int) {.magic: \"SetLengthStr\", noSideEffect.}"
  }, 
  {
    "name": "newString", 
    "type": "skProc", 
    "description": "returns a new string of length <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt> but with uninitialized content. One needs to fill the string character after character with the index operator <tt class=\"docutils literal\"><span class=\"pre\">s[i]</span></tt>. This procedure exists only for optimization purposes; the same effect can be achieved with the <tt class=\"docutils literal\"><span class=\"pre\">&amp;</span></tt> operator or with <tt class=\"docutils literal\"><span class=\"pre\">add</span></tt>.", 
    "code": "proc newString*(len: int): string {.magic: \"NewString\", importc: \"mnewString\", \u000D\u000A                                    noSideEffect.}"
  }, 
  {
    "name": "newStringOfCap", 
    "type": "skProc", 
    "description": "returns a new string of length <tt class=\"docutils literal\"><span class=\"pre\">0</span></tt> but with capacity <cite>cap</cite>.This procedure exists only for optimization purposes; the same effect can be achieved with the <tt class=\"docutils literal\"><span class=\"pre\">&amp;</span></tt> operator or with <tt class=\"docutils literal\"><span class=\"pre\">add</span></tt>.", 
    "code": "proc newStringOfCap*(cap: int): string {.magic: \"NewStringOfCap\", \u000D\u000A    importc: \"rawNewString\", noSideEffect.}"
  }, 
  {
    "name": "`&amp;`", 
    "type": "skProc", 
    "code": "proc `&`*(x: string; y: char): string {.magic: \"ConStrStr\", noSideEffect, merge.}"
  }, 
  {
    "name": "`&amp;`", 
    "type": "skProc", 
    "code": "proc `&`*(x: char; y: char): string {.magic: \"ConStrStr\", noSideEffect, merge.}"
  }, 
  {
    "name": "`&amp;`", 
    "type": "skProc", 
    "code": "proc `&`*(x, y: string): string {.magic: \"ConStrStr\", noSideEffect, merge.}"
  }, 
  {
    "name": "`&amp;`", 
    "type": "skProc", 
    "description": "is the <cite>concatenation operator</cite>. It concatenates <cite>x</cite> and <cite>y</cite>.", 
    "code": "proc `&`*(x: char; y: string): string {.magic: \"ConStrStr\", noSideEffect, merge.}"
  }, 
  {
    "name": "add", 
    "type": "skProc", 
    "code": "proc add*(x: var string; y: char) {.magic: \"AppendStrCh\", noSideEffect.}"
  }, 
  {
    "name": "add", 
    "type": "skProc", 
    "code": "proc add*(x: var string; y: string) {.magic: \"AppendStrStr\", noSideEffect.}"
  }, 
  {
    "name": "TEndian", 
    "type": "skType", 
    "description": "is a type describing the endianness of a processor.", 
    "code": "TEndian* = enum \u000D\u000A  littleEndian, bigEndian"
  }, 
  {
    "name": "compileOption", 
    "type": "skProc", 
    "description": "can be used to determine an on|off compile-time option. Example:<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">compileOption</span><span class=\"Punctation\">(</span><span class=\"StringLit\">&quot;floatchecks&quot;</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span>\u000D\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;compiled with floating point NaN and Inf checks&quot;</span></pre>", 
    "code": "proc compileOption*(option: string): bool {.magic: \"CompileOption\", noSideEffect.}"
  }, 
  {
    "name": "compileOption", 
    "type": "skProc", 
    "description": "can be used to determine an enum compile-time option. Example:<pre><span class=\"Keyword\">when</span> <span class=\"Identifier\">compileOption</span><span class=\"Punctation\">(</span><span class=\"StringLit\">&quot;opt&quot;</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;size&quot;</span><span class=\"Punctation\">)</span> <span class=\"Keyword\">and</span> <span class=\"Identifier\">compileOption</span><span class=\"Punctation\">(</span><span class=\"StringLit\">&quot;gc&quot;</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;boehm&quot;</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span>\u000D\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;compiled with optimization for size and uses Boehm's GC&quot;</span></pre>", 
    "code": "proc compileOption*(option, arg: string): bool {.magic: \"CompileOptionArg\", \u000D\u000A    noSideEffect.}"
  }, 
  {
    "name": "TaintedString", 
    "type": "skType", 
    "description": "a distinct string type that is <span id=\"tainted_638041214\">tainted</span>. It is an alias for <tt class=\"docutils literal\"><span class=\"pre\">string</span></tt> if the taint mode is not turned on. Use the <tt class=\"docutils literal\"><span class=\"pre\">-d:taintMode</span></tt> command line switch to turn the taint mode on.", 
    "code": "TaintedString* = distinct string"
  }, 
  {
    "name": "len", 
    "type": "skProc", 
    "code": "proc len*(s: TaintedString): int {.borrow.}"
  }, 
  {
    "name": "QuitFailure", 
    "type": "skConst", 
    "description": "is the value that should be passed to <tt class=\"docutils literal\"><span class=\"pre\">quit</span></tt> to indicate failure.", 
    "code": "QuitFailure* = 1"
  }, 
  {
    "name": "programResult", 
    "type": "skVar", 
    "description": "modify this varialbe to specify the exit code of the program under normal circumstances. When the program is terminated prematurelly using <tt class=\"docutils literal\"><span class=\"pre\">quit</span></tt>, this value is ignored.", 
    "code": "programResult* {.exportc: \"nim_program_result\".}: int"
  }, 
  {
    "name": "quit", 
    "type": "skProc", 
    "description": "<p>Stops the program immediately with an exit code.</p>\u000D\u000A<p>Before stopping the program the &quot;quit procedures&quot; are called in the opposite order they were added with <tt class=\"docutils literal\"><span class=\"pre\">addQuitProc</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">quit</span></tt> never returns and ignores any exception that may have been raised by the quit procedures.  It does <em>not</em> call the garbage collector to free all the memory, unless a quit procedure calls <tt class=\"docutils literal\"><span class=\"pre\">GC_collect</span></tt>.</p>\u000D\u000A<p>The proc <tt class=\"docutils literal\"><span class=\"pre\">quit(QuitSuccess)</span></tt> is called implicitly when your nimrod program finishes without incident. A raised unhandled exception is equivalent to calling <tt class=\"docutils literal\"><span class=\"pre\">quit(QuitFailure)</span></tt>.</p>\u000D\u000A", 
    "code": "proc quit*(errorcode: int = QuitSuccess) {.magic: \"Exit\", importc: \"exit\", \u000D\u000A    header: \"<stdlib.h>\", noReturn.}"
  }, 
  {
    "name": "add", 
    "type": "skProc", 
    "code": "proc add*[T](x: var seq[T]; y: T) {.magic: \"AppendSeqElem\", noSideEffect.}"
  }, 
  {
    "name": "add", 
    "type": "skProc", 
    "description": "Generic proc for adding a data item <cite>y</cite> to a container <cite>x</cite>. For containers that have an order, <cite>add</cite> means <em>append</em>. New generic containers should also call their adding proc <cite>add</cite> for consistency. Generic code becomes much easier to write if the Nimrod naming scheme is respected.", 
    "code": "proc add*[T](x: var seq[T]; y: openArray[T]) {.noSideEffect.}"
  }, 
  {
    "name": "shallowCopy", 
    "type": "skProc", 
    "description": "use this instead of <cite>=</cite> for a <span id=\"shallow-copy_1373330629\">shallow copy</span>. The shallow copy only changes the semantics for sequences and strings (and types which contain those). Be careful with the changed semantics though! There is a reason why the default assignment does a deep copy of sequences and strings.", 
    "code": "proc shallowCopy*[T](x: var T; y: T) {.noSideEffect, magic: \"ShallowCopy\".}"
  }, 
  {
    "name": "del", 
    "type": "skProc", 
    "description": "deletes the item at index <cite>i</cite> by putting <tt class=\"docutils literal\"><span class=\"pre\">x[high(x)]</span></tt> into position <cite>i</cite>. This is an O(1) operation.", 
    "code": "proc del*[T](x: var seq[T]; i: int) {.noSideEffect.}"
  }, 
  {
    "name": "delete", 
    "type": "skProc", 
    "description": "deletes the item at index <cite>i</cite> by moving <tt class=\"docutils literal\"><span class=\"pre\">x[i+1..]</span></tt> by one position. This is an O(n) operation.", 
    "code": "proc delete*[T](x: var seq[T]; i: int) {.noSideEffect.}"
  }, 
  {
    "name": "insert", 
    "type": "skProc", 
    "description": "inserts <cite>item</cite> into <cite>x</cite> at position <cite>i</cite>.", 
    "code": "proc insert*[T](x: var seq[T]; item: T; i = 0) {.noSideEffect.}"
  }, 
  {
    "name": "repr", 
    "type": "skProc", 
    "description": "takes any Nimrod variable and returns its string representation. It works even for complex data graphs with cycles. This is a great debugging tool.", 
    "code": "proc repr*[T](x: T): string {.magic: \"Repr\", noSideEffect.}"
  }, 
  {
    "name": "BiggestFloat", 
    "type": "skType", 
    "description": "is an alias for the biggest floating point type the Nimrod compiler supports. Currently this is <tt class=\"docutils literal\"><span class=\"pre\">float64</span></tt>, but it is platform-dependant in general.", 
    "code": "BiggestFloat* = float64"
  }, 
  {
    "name": "culong", 
    "type": "skType", 
    "description": "This is the same as the type <tt class=\"docutils literal\"><span class=\"pre\">unsigned long</span></tt> in <em>C</em>.", 
    "code": "culong* {.importc: \"unsigned long\", nodecl.} = uint32"
  }, 
  {
    "name": "PInt32", 
    "type": "skType", 
    "description": "an alias for <tt class=\"docutils literal\"><span class=\"pre\">ptr int32</span></tt>", 
    "code": "PInt32* = ptr int32"
  }, 
  {
    "name": "toFloat", 
    "type": "skProc", 
    "description": "converts an integer <cite>i</cite> into a <tt class=\"docutils literal\"><span class=\"pre\">float</span></tt>. If the conversion fails, <cite>EInvalidValue</cite> is raised. However, on most platforms the conversion cannot fail.", 
    "code": "proc toFloat*(i: int): float {.magic: \"ToFloat\", noSideEffect, \u000D\u000A                               importc: \"toFloat\".}"
  }, 
  {
    "name": "toBiggestFloat", 
    "type": "skProc", 
    "description": "converts an biggestint <cite>i</cite> into a <tt class=\"docutils literal\"><span class=\"pre\">biggestfloat</span></tt>. If the conversion fails, <cite>EInvalidValue</cite> is raised. However, on most platforms the conversion cannot fail.", 
    "code": "proc toBiggestFloat*(i: biggestint): biggestfloat {.magic: \"ToBiggestFloat\", \u000D\u000A    noSideEffect, importc: \"toBiggestFloat\".}"
  }, 
  {
    "name": "toInt", 
    "type": "skProc", 
    "description": "converts a floating point number <cite>f</cite> into an <tt class=\"docutils literal\"><span class=\"pre\">int</span></tt>. Conversion rounds <cite>f</cite> if it does not contain an integer value. If the conversion fails (because <cite>f</cite> is infinite for example), <cite>EInvalidValue</cite> is raised.", 
    "code": "proc toInt*(f: float): int {.magic: \"ToInt\", noSideEffect, importc: \"toInt\".}"
  }, 
  {
    "name": "toBiggestInt", 
    "type": "skProc", 
    "description": "converts a biggestfloat <cite>f</cite> into a <tt class=\"docutils literal\"><span class=\"pre\">biggestint</span></tt>. Conversion rounds <cite>f</cite> if it does not contain an integer value. If the conversion fails (because <cite>f</cite> is infinite for example), <cite>EInvalidValue</cite> is raised.", 
    "code": "proc toBiggestInt*(f: biggestfloat): biggestint {.magic: \"ToBiggestInt\", \u000D\u000A    noSideEffect, importc: \"toBiggestInt\".}"
  }, 
  {
    "name": "addQuitProc", 
    "type": "skProc", 
    "description": "adds/registers a quit procedure. Each call to <tt class=\"docutils literal\"><span class=\"pre\">addQuitProc</span></tt> registers another quit procedure. Up to 30 procedures can be registered. They are executed on a last-in, first-out basis (that is, the last function registered is the first to be executed). <tt class=\"docutils literal\"><span class=\"pre\">addQuitProc</span></tt> raises an EOutOfIndex if <tt class=\"docutils literal\"><span class=\"pre\">quitProc</span></tt> cannot be registered.", 
    "code": "proc addQuitProc*(QuitProc: proc () {.noconv.}) {.importc: \"atexit\", \u000D\u000A    header: \"<stdlib.h>\".}"
  }, 
  {
    "name": "copy", 
    "type": "skProc", 
    "code": "proc copy*(s: string; first = 0): string {.magic: \"CopyStr\", importc: \"copyStr\", \u000D\u000A    noSideEffect, deprecated.}"
  }, 
  {
    "name": "copy", 
    "type": "skProc", 
    "description": "copies a slice of <cite>s</cite> into a new string and returns this new string. The bounds <cite>first</cite> and <cite>last</cite> denote the indices of the first and last characters that shall be copied. If <tt class=\"docutils literal\"><span class=\"pre\">last</span></tt> is omitted, it is treated as <tt class=\"docutils literal\"><span class=\"pre\">high(s)</span></tt>. <strong>Deprecated since version 0.8.12</strong>: Use <tt class=\"docutils literal\"><span class=\"pre\">substr</span></tt> instead.", 
    "code": "proc copy*(s: string; first, last: int): string {.magic: \"CopyStrLast\", \u000D\u000A    importc: \"copyStrLast\", noSideEffect, deprecated.}"
  }, 
  {
    "name": "substr", 
    "type": "skProc", 
    "code": "proc substr*(s: string; first = 0): string {.magic: \"CopyStr\", \u000D\u000A    importc: \"copyStr\", noSideEffect.}"
  }, 
  {
    "name": "substr", 
    "type": "skProc", 
    "description": "copies a slice of <cite>s</cite> into a new string and returns this new string. The bounds <cite>first</cite> and <cite>last</cite> denote the indices of the first and last characters that shall be copied. If <tt class=\"docutils literal\"><span class=\"pre\">last</span></tt> is omitted, it is treated as <tt class=\"docutils literal\"><span class=\"pre\">high(s)</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">last &gt;= s.len</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">s.len</span></tt> is used instead: This means <tt class=\"docutils literal\"><span class=\"pre\">substr</span></tt> can also be used to <span id=\"cut_367918002\">cut</span> or <span id=\"limit_1294753637\">limit</span> a string's length.", 
    "code": "proc substr*(s: string; first, last: int): string {.magic: \"CopyStrLast\", \u000D\u000A    importc: \"copyStrLast\", noSideEffect.}"
  }, 
  {
    "name": "zeroMem", 
    "type": "skProc", 
    "description": "overwrites the contents of the memory at <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt> with the value 0. Exactly <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes will be overwritten. Like any procedure dealing with raw memory this is <em>unsafe</em>.", 
    "code": "proc zeroMem*(p: Pointer; size: int) {.importc, noDecl.}"
  }, 
  {
    "name": "copyMem", 
    "type": "skProc", 
    "description": "copies the contents from the memory at <tt class=\"docutils literal\"><span class=\"pre\">source</span></tt> to the memory at <tt class=\"docutils literal\"><span class=\"pre\">dest</span></tt>. Exactly <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes will be copied. The memory regions may not overlap. Like any procedure dealing with raw memory this is <em>unsafe</em>.", 
    "code": "proc copyMem*(dest, source: Pointer; size: int) {.importc: \"memcpy\", \u000D\u000A    header: \"<string.h>\".}"
  }, 
  {
    "name": "moveMem", 
    "type": "skProc", 
    "description": "copies the contents from the memory at <tt class=\"docutils literal\"><span class=\"pre\">source</span></tt> to the memory at <tt class=\"docutils literal\"><span class=\"pre\">dest</span></tt>. Exactly <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes will be copied. The memory regions may overlap, <tt class=\"docutils literal\"><span class=\"pre\">moveMem</span></tt> handles this case appropriately and is thus somewhat more safe than <tt class=\"docutils literal\"><span class=\"pre\">copyMem</span></tt>. Like any procedure dealing with raw memory this is still <em>unsafe</em>, though.", 
    "code": "proc moveMem*(dest, source: Pointer; size: int) {.importc: \"memmove\", \u000D\u000A    header: \"<string.h>\".}"
  }, 
  {
    "name": "equalMem", 
    "type": "skProc", 
    "description": "compares the memory blocks <tt class=\"docutils literal\"><span class=\"pre\">a</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">b</span></tt>. <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes will be compared. If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is <em>unsafe</em>.", 
    "code": "proc equalMem*(a, b: Pointer; size: int): bool {.importc: \"equalMem\", noDecl, \u000D\u000A    noSideEffect.}"
  }, 
  {
    "name": "alloc", 
    "type": "skProc", 
    "description": "allocates a new memory block with at least <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">realloc(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">dealloc(block)</span></tt>. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use <cite>allocShared</cite> to allocate from a shared heap.", 
    "code": "proc alloc*(size: int): pointer {.noconv, rtl, tags: [].}"
  }, 
  {
    "name": "alloc0", 
    "type": "skProc", 
    "description": "allocates a new memory block with at least <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">realloc(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">dealloc(block)</span></tt>. The block is initialized with all bytes containing zero, so it is somewhat safer than <tt class=\"docutils literal\"><span class=\"pre\">alloc</span></tt>. The allocated memory belongs to its allocating thread! Use <cite>allocShared0</cite> to allocate from a shared heap.", 
    "code": "proc alloc0*(size: int): pointer {.noconv, rtl, tags: [].}"
  }, 
  {
    "name": "realloc", 
    "type": "skProc", 
    "description": "grows or shrinks a given memory block. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <tt class=\"docutils literal\"><span class=\"pre\">newsize</span></tt> bytes. If <tt class=\"docutils literal\"><span class=\"pre\">newsize == 0</span></tt> and p is not <strong>nil</strong> <tt class=\"docutils literal\"><span class=\"pre\">realloc</span></tt> calls <tt class=\"docutils literal\"><span class=\"pre\">dealloc(p)</span></tt>. In other cases the block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">dealloc</span></tt>. The allocated memory belongs to its allocating thread! Use <cite>reallocShared</cite> to reallocate from a shared heap.", 
    "code": "proc realloc*(p: Pointer; newsize: int): pointer {.noconv, rtl, tags: [].}"
  }, 
  {
    "name": "dealloc", 
    "type": "skProc", 
    "description": "frees the memory allocated with <tt class=\"docutils literal\"><span class=\"pre\">alloc</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">alloc0</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">realloc</span></tt>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted. The freed memory must belong to its allocating thread! Use <cite>deallocShared</cite> to deallocate from a shared heap.", 
    "code": "proc dealloc*(p: Pointer) {.noconv, rtl, tags: [].}"
  }, 
  {
    "name": "allocShared", 
    "type": "skProc", 
    "description": "allocates a new memory block on the shared heap with at least <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">reallocShared(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">deallocShared(block)</span></tt>. The block is not initialized, so reading from it before writing to it is undefined behaviour!", 
    "code": "proc allocShared*(size: int): pointer {.noconv, rtl.}"
  }, 
  {
    "name": "allocShared0", 
    "type": "skProc", 
    "description": "allocates a new memory block on the shared heap with at least <tt class=\"docutils literal\"><span class=\"pre\">size</span></tt> bytes. The block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">reallocShared(block, 0)</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">deallocShared(block)</span></tt>. The block is initialized with all bytes containing zero, so it is somewhat safer than <tt class=\"docutils literal\"><span class=\"pre\">allocShared</span></tt>.", 
    "code": "proc allocShared0*(size: int): pointer {.noconv, rtl.}"
  }, 
  {
    "name": "reallocShared", 
    "type": "skProc", 
    "description": "grows or shrinks a given memory block on the heap. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <tt class=\"docutils literal\"><span class=\"pre\">newsize</span></tt> bytes. If <tt class=\"docutils literal\"><span class=\"pre\">newsize == 0</span></tt> and p is not <strong>nil</strong> <tt class=\"docutils literal\"><span class=\"pre\">reallocShared</span></tt> calls <tt class=\"docutils literal\"><span class=\"pre\">deallocShared(p)</span></tt>. In other cases the block has to be freed with <tt class=\"docutils literal\"><span class=\"pre\">deallocShared</span></tt>.", 
    "code": "proc reallocShared*(p: Pointer; newsize: int): pointer {.noconv, rtl.}"
  }, 
  {
    "name": "deallocShared", 
    "type": "skProc", 
    "description": "frees the memory allocated with <tt class=\"docutils literal\"><span class=\"pre\">allocShared</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">allocShared0</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">reallocShared</span></tt>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.", 
    "code": "proc deallocShared*(p: Pointer) {.noconv, rtl.}"
  }, 
  {
    "name": "swap", 
    "type": "skProc", 
    "description": "swaps the values <cite>a</cite> and <cite>b</cite>. This is often more efficient than <tt class=\"docutils literal\"><span class=\"pre\">tmp = a; a = b; b = tmp</span></tt>. Particularly useful for sorting algorithms.", 
    "code": "proc swap*[T](a, b: var T) {.magic: \"Swap\", noSideEffect.}"
  }, 
  {
    "name": "`&gt;=%`", 
    "type": "skTemplate", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compares them. Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &gt;= unsigned(y)</span></tt>.", 
    "code": "template `>=%`*(x, y: expr): expr {.immediate.}"
  }, 
  {
    "name": "`&gt;%`", 
    "type": "skTemplate", 
    "description": "treats <cite>x</cite> and <cite>y</cite> as unsigned and compares them. Returns true iff <tt class=\"docutils literal\"><span class=\"pre\">unsigned(x) &gt; unsigned(y)</span></tt>.", 
    "code": "template `>%`*(x, y: expr): expr {.immediate.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for an integer argument. Returns <cite>x</cite> converted to a decimal string.", 
    "code": "proc `$`*(x: int): string {.magic: \"IntToStr\", noSideEffect.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for an integer argument. Returns <cite>x</cite> converted to a decimal string.", 
    "code": "proc `$`*(x: int64): string {.magic: \"Int64ToStr\", noSideEffect.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for an unsigned integer argument. Returns <cite>x</cite> converted to a decimal string.", 
    "code": "proc `$`*(x: uint64): string {.noSideEffect.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for a float argument. Returns <cite>x</cite> converted to a decimal string.", 
    "code": "proc `$`*(x: float): string {.magic: \"FloatToStr\", noSideEffect.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for a boolean argument. Returns <cite>x</cite> converted to the string &quot;false&quot; or &quot;true&quot;.", 
    "code": "proc `$`*(x: bool): string {.magic: \"BoolToStr\", noSideEffect.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for a character argument. Returns <cite>x</cite> converted to a string.", 
    "code": "proc `$`*(x: char): string {.magic: \"CharToStr\", noSideEffect.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for a CString argument. Returns <cite>x</cite> converted to a string.", 
    "code": "proc `$`*(x: Cstring): string {.magic: \"CStrToStr\", noSideEffect.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for a string argument. Returns <cite>x</cite> as it is. This operator is useful for generic code, so that <tt class=\"docutils literal\"><span class=\"pre\">$expr</span></tt> also works if <tt class=\"docutils literal\"><span class=\"pre\">expr</span></tt> is already a string.", 
    "code": "proc `$`*(x: string): string {.magic: \"StrToStr\", noSideEffect.}"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "The stingify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator for a concrete enumeration is provided, this is used instead. (In other words: <em>Overwriting</em> is possible.)", 
    "code": "proc `$`*[TEnum: enum](x: TEnum): string {.magic: \"EnumToStr\", noSideEffect.}"
  }, 
  {
    "name": "getRefcount", 
    "type": "skProc", 
    "code": "proc getRefcount*[T](x: ref T): int {.importc: \"getRefcount\", noSideEffect.}"
  }, 
  {
    "name": "getRefcount", 
    "type": "skProc", 
    "code": "proc getRefcount*(x: string): int {.importc: \"getRefcount\", noSideEffect.}"
  }, 
  {
    "name": "getRefcount", 
    "type": "skProc", 
    "description": "retrieves the reference count of an heap-allocated object. The value is implementation-dependent.", 
    "code": "proc getRefcount*[T](x: seq[T]): int {.importc: \"getRefcount\", noSideEffect.}"
  }, 
  {
    "name": "nan", 
    "type": "skConst", 
    "description": "contains an IEEE floating point value of <em>Not A Number</em>. Note that you cannot compare a floating point value to this value and expect a reasonable result - use the <cite>classify</cite> procedure in the module <tt class=\"docutils literal\"><span class=\"pre\">math</span></tt> for checking for NaN.", 
    "code": "nan* {.magic: \"NaN\".} = 0.0000000000000000e+000 / 0.0000000000000000e+000"
  }, 
  {
    "name": "getOccupiedMem", 
    "type": "skProc", 
    "description": "returns the number of bytes that are owned by the process and hold data.", 
    "code": "proc getOccupiedMem*(): int {.rtl.}"
  }, 
  {
    "name": "getFreeMem", 
    "type": "skProc", 
    "description": "returns the number of bytes that are owned by the process, but do not hold any meaningful data.", 
    "code": "proc getFreeMem*(): int {.rtl.}"
  }, 
  {
    "name": "getTotalMem", 
    "type": "skProc", 
    "description": "returns the number of bytes that are owned by the process.", 
    "code": "proc getTotalMem*(): int {.rtl.}"
  }, 
  {
    "name": "countdown", 
    "type": "skIterator", 
    "description": "Counts from ordinal value <cite>a</cite> down to <cite>b</cite> with the given step count. <cite>T</cite> may be any ordinal type, <cite>step</cite> may only be positive.", 
    "code": "iterator countdown*[T](a, b: T; step = 1): T {.inline.}"
  }, 
  {
    "name": "countup", 
    "type": "skIterator", 
    "description": "Counts from ordinal value <cite>a</cite> up to <cite>b</cite> with the given step count. <cite>S</cite>, <cite>T</cite> may be any ordinal type, <cite>step</cite> may only be positive.", 
    "code": "iterator countup*[S, T](a: S; b: T; step = 1): T {.inline.}"
  }, 
  {
    "name": "`..`", 
    "type": "skIterator", 
    "description": "An alias for <cite>countup</cite>.", 
    "code": "iterator `..`*[S, T](a: S; b: T): T {.inline.}"
  }, 
  {
    "name": "`||`", 
    "type": "skIterator", 
    "description": "parallel loop iterator. Same as <cite>..</cite> but the loop may run in parallel. <cite>annotation</cite> is an additional annotation for the code generator to use. Note that the compiler maps that to the <tt class=\"docutils literal\"><span class=\"pre\">#pragma omp parallel for</span></tt> construct of <span id=\"openmp_1408930991\">OpenMP</span> and as such isn't aware of the parallelism in your code! Be careful! Later versions of <tt class=\"docutils literal\"><span class=\"pre\">||</span></tt> will get proper support by Nimrod's code generator and GC.", 
    "code": "iterator `||`*[S, T](a: S; b: T; annotation = \"\"): T {.inline, \u000D\u000A    magic: \"OmpParFor\", sideEffect.}"
  }, 
  {
    "name": "min", 
    "type": "skProc", 
    "code": "proc min*(x, y: int): int {.magic: \"MinI\", noSideEffect.}"
  }, 
  {
    "name": "min", 
    "type": "skProc", 
    "code": "proc min*(x, y: int8): int8 {.magic: \"MinI\", noSideEffect.}"
  }, 
  {
    "name": "min", 
    "type": "skProc", 
    "code": "proc min*(x, y: int16): int16 {.magic: \"MinI\", noSideEffect.}"
  }, 
  {
    "name": "min", 
    "type": "skProc", 
    "code": "proc min*(x, y: int32): int32 {.magic: \"MinI\", noSideEffect.}"
  }, 
  {
    "name": "min", 
    "type": "skProc", 
    "description": "The minimum value of two integers.", 
    "code": "proc min*(x, y: int64): int64 {.magic: \"MinI64\", noSideEffect.}"
  }, 
  {
    "name": "min", 
    "type": "skProc", 
    "description": "The minimum value of <cite>x</cite>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> needs to have a <tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> operator.", 
    "code": "proc min*[T](x: varargs[T]): T"
  }, 
  {
    "name": "max", 
    "type": "skProc", 
    "code": "proc max*(x, y: int): int {.magic: \"MaxI\", noSideEffect.}"
  }, 
  {
    "name": "max", 
    "type": "skProc", 
    "code": "proc max*(x, y: int8): int8 {.magic: \"MaxI\", noSideEffect.}"
  }, 
  {
    "name": "max", 
    "type": "skProc", 
    "code": "proc max*(x, y: int16): int16 {.magic: \"MaxI\", noSideEffect.}"
  }, 
  {
    "name": "max", 
    "type": "skProc", 
    "code": "proc max*(x, y: int32): int32 {.magic: \"MaxI\", noSideEffect.}"
  }, 
  {
    "name": "max", 
    "type": "skProc", 
    "description": "The maximum value of two integers.", 
    "code": "proc max*(x, y: int64): int64 {.magic: \"MaxI64\", noSideEffect.}"
  }, 
  {
    "name": "max", 
    "type": "skProc", 
    "description": "The maximum value of <cite>x</cite>. <tt class=\"docutils literal\"><span class=\"pre\">T</span></tt> needs to have a <tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> operator.", 
    "code": "proc max*[T](x: varargs[T]): T"
  }, 
  {
    "name": "abs", 
    "type": "skProc", 
    "code": "proc abs*(x: float): float {.magic: \"AbsF64\", noSideEffect.}"
  }, 
  {
    "name": "min", 
    "type": "skProc", 
    "code": "proc min*(x, y: float): float {.magic: \"MinF64\", noSideEffect.}"
  }, 
  {
    "name": "max", 
    "type": "skProc", 
    "code": "proc max*(x, y: float): float {.magic: \"MaxF64\", noSideEffect.}"
  }, 
  {
    "name": "clamp", 
    "type": "skProc", 
    "description": "limits the value <tt class=\"docutils literal\"><span class=\"pre\">x</span></tt> within the interval [a, b] ", 
    "code": "proc clamp*[T](x, a, b: T): T"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>.", 
    "code": "iterator items*[T](a: openarray[T]): T {.inline.}"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>.", 
    "code": "iterator items*[IX, T](a: array[IX, T]): T {.inline.}"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>.", 
    "code": "iterator items*[T](a: seq[T]): T {.inline.}"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>.", 
    "code": "iterator items*(a: string): char {.inline.}"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "iterates over each element of <cite>a</cite>. <cite>items</cite> iterates only over the elements that are really in the set (and not over the ones the set is able to hold).", 
    "code": "iterator items*[T](a: set[T]): T {.inline.}"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>.", 
    "code": "iterator items*(a: cstring): char {.inline.}"
  }, 
  {
    "name": "items", 
    "type": "skIterator", 
    "description": "iterates over the values of the enum <tt class=\"docutils literal\"><span class=\"pre\">E</span></tt>.", 
    "code": "iterator items*(E: typedesc[enum]): E"
  }, 
  {
    "name": "pairs", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>. Yields <tt class=\"docutils literal\"><span class=\"pre\">(index, a[index])</span></tt> pairs.", 
    "code": "iterator pairs*[T](a: openarray[T]): tuple[key: int, val: T] {.inline.}"
  }, 
  {
    "name": "pairs", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>. Yields <tt class=\"docutils literal\"><span class=\"pre\">(index, a[index])</span></tt> pairs.", 
    "code": "iterator pairs*[IX, T](a: array[IX, T]): tuple[key: IX, val: T] {.inline.}"
  }, 
  {
    "name": "pairs", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>. Yields <tt class=\"docutils literal\"><span class=\"pre\">(index, a[index])</span></tt> pairs.", 
    "code": "iterator pairs*[T](a: seq[T]): tuple[key: int, val: T] {.inline.}"
  }, 
  {
    "name": "pairs", 
    "type": "skIterator", 
    "description": "iterates over each item of <cite>a</cite>. Yields <tt class=\"docutils literal\"><span class=\"pre\">(index, a[index])</span></tt> pairs.", 
    "code": "iterator pairs*(a: string): tuple[key: int, val: char] {.inline.}"
  }, 
  {
    "name": "isNil", 
    "type": "skProc", 
    "code": "proc isNil*[T](x: seq[T]): bool {.noSideEffect, magic: \"IsNil\".}"
  }, 
  {
    "name": "isNil", 
    "type": "skProc", 
    "code": "proc isNil*[T](x: ref T): bool {.noSideEffect, magic: \"IsNil\".}"
  }, 
  {
    "name": "isNil", 
    "type": "skProc", 
    "code": "proc isNil*(x: string): bool {.noSideEffect, magic: \"IsNil\".}"
  }, 
  {
    "name": "isNil", 
    "type": "skProc", 
    "code": "proc isNil*[T](x: ptr T): bool {.noSideEffect, magic: \"IsNil\".}"
  }, 
  {
    "name": "isNil", 
    "type": "skProc", 
    "code": "proc isNil*(x: pointer): bool {.noSideEffect, magic: \"IsNil\".}"
  }, 
  {
    "name": "isNil", 
    "type": "skProc", 
    "code": "proc isNil*(x: cstring): bool {.noSideEffect, magic: \"IsNil\".}"
  }, 
  {
    "name": "isNil", 
    "type": "skProc", 
    "description": "Fast check whether <cite>x</cite> is nil. This is sometimes more efficient than <tt class=\"docutils literal\"><span class=\"pre\">== nil</span></tt>.", 
    "code": "proc isNil*[T: proc](x: T): bool {.noSideEffect, magic: \"IsNil\".}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "code": "proc `==`*[I, T](x, y: array[I, T]): bool"
  }, 
  {
    "name": "`@`", 
    "type": "skProc", 
    "description": "turns an openarray into a sequence. This is not as efficient as turning a fixed length array into a sequence as it always copies every element of <cite>a</cite>.", 
    "code": "proc `@`*[T](a: openArray[T]): seq[T]"
  }, 
  {
    "name": "`&amp;`", 
    "type": "skProc", 
    "code": "proc `&`*[T](x, y: seq[T]): seq[T] {.noSideEffect.}"
  }, 
  {
    "name": "`&amp;`", 
    "type": "skProc", 
    "code": "proc `&`*[T](x: seq[T]; y: T): seq[T] {.noSideEffect.}"
  }, 
  {
    "name": "`&amp;`", 
    "type": "skProc", 
    "code": "proc `&`*[T](x: T; y: seq[T]): seq[T] {.noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "description": "Generic equals operator for sequences: relies on a equals operator for the element type <cite>T</cite>.", 
    "code": "proc `==`*[T](x, y: seq[T]): bool {.noSideEffect.}"
  }, 
  {
    "name": "find", 
    "type": "skProc", 
    "description": "Returns the first index of <cite>item</cite> in <cite>a</cite> or -1 if not found. This requires appropriate <cite>items</cite> and <cite>==</cite> operations to work.", 
    "code": "proc find*[T, S](a: T; item: S): int {.inline.}"
  }, 
  {
    "name": "contains", 
    "type": "skProc", 
    "description": "Returns true if <cite>item</cite> is in <cite>a</cite> or false if not found. This is a shortcut for <tt class=\"docutils literal\"><span class=\"pre\">find(a, item) &gt;= 0</span></tt>.", 
    "code": "proc contains*[T](a: openArray[T]; item: T): bool {.inline.}"
  }, 
  {
    "name": "pop", 
    "type": "skProc", 
    "description": "returns the last item of <cite>s</cite> and decreases <tt class=\"docutils literal\"><span class=\"pre\">s.len</span></tt> by one. This treats <cite>s</cite> as a stack and implements the common <em>pop</em> operation.", 
    "code": "proc pop*[T](s: var seq[T]): T {.inline, noSideEffect.}"
  }, 
  {
    "name": "each", 
    "type": "skProc", 
    "description": "<p>The well-known <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> operation from functional programming. Applies <cite>op</cite> to every item in <cite>data</cite> and returns the result as a sequence.</p>\u000D\u000A<p><strong>Deprecated since version 0.9:</strong> Use the <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> proc instead.</p>\u000D\u000A", 
    "code": "proc each*[T, S](data: openArray[T]; op: proc (x: T): S {.closure.}): seq[S] {.\u000D\u000A    deprecated.}"
  }, 
  {
    "name": "each", 
    "type": "skProc", 
    "description": "<p>The well-known <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> operation from functional programming. Applies <cite>op</cite> to every item in <cite>data</cite> modifying it directly.</p>\u000D\u000A<p><strong>Deprecated since version 0.9:</strong> Use the <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> proc instead.</p>\u000D\u000A", 
    "code": "proc each*[T](data: var openArray[T]; op: proc (x: var T) {.closure.}) {.\u000D\u000A    deprecated.}"
  }, 
  {
    "name": "map", 
    "type": "skProc", 
    "description": "<p>Returns a new sequence with the results of <cite>op</cite> applied to every item in <cite>data</cite>.</p>\u000D\u000A<p>Since the input is not modified you can use this version of <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> to transform the type of the elements in the input sequence. Example:</p>\u000D\u000A<pre><span class=\"Keyword\">let</span>\u000D\u000A  <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctation\">,</span> <span class=\"DecNumber\">4</span><span class=\"Punctation\">]</span>\u000D\u000A  <span class=\"Identifier\">b</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">map</span><span class=\"Punctation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctation\">,</span> <span class=\"Keyword\">proc</span><span class=\"Punctation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">string</span> <span class=\"Operator\">=</span> <span class=\"Operator\">$</span><span class=\"Identifier\">x</span><span class=\"Punctation\">)</span>\u000D\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">b</span> <span class=\"Operator\">==</span> <span class=\"Operator\">@</span><span class=\"Punctation\">[</span><span class=\"StringLit\">&quot;1&quot;</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;2&quot;</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;3&quot;</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;4&quot;</span><span class=\"Punctation\">]</span></pre>", 
    "code": "proc map*[T, S](data: openArray[T]; op: proc (x: T): S {.closure.}): seq[S]"
  }, 
  {
    "name": "map", 
    "type": "skProc", 
    "description": "<p>Applies <cite>op</cite> to every item in <cite>data</cite> modifying it directly.</p>\u000D\u000A<p>Note that this version of <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> requires your input and output types to be the same, since they are modified in-place. Example:</p>\u000D\u000A<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctation\">[</span><span class=\"StringLit\">&quot;1&quot;</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;2&quot;</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;3&quot;</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;4&quot;</span><span class=\"Punctation\">]</span>\u000D\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">repr</span><span class=\"Punctation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctation\">)</span>\u000D\u000A<span class=\"Comment\"># --&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]</span>\u000D\u000A<span class=\"Identifier\">map</span><span class=\"Punctation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctation\">,</span> <span class=\"Keyword\">proc</span><span class=\"Punctation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctation\">:</span> <span class=\"Keyword\">var</span> <span class=\"Identifier\">string</span><span class=\"Punctation\">)</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">x</span> <span class=\"Operator\">&amp;=</span> <span class=\"StringLit\">&quot;42&quot;</span><span class=\"Punctation\">)</span>\u000D\u000A<span class=\"Identifier\">echo</span> <span class=\"Identifier\">repr</span><span class=\"Punctation\">(</span><span class=\"Identifier\">a</span><span class=\"Punctation\">)</span>\u000D\u000A<span class=\"Comment\"># --&gt; [&quot;142&quot;, &quot;242&quot;, &quot;342&quot;, &quot;442&quot;]</span></pre>", 
    "code": "proc map*[T](data: var openArray[T]; op: proc (x: var T) {.closure.})"
  }, 
  {
    "name": "fields", 
    "type": "skIterator", 
    "description": "iterates over every field of <cite>x</cite>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.", 
    "code": "iterator fields*[T: tuple |\u000D\u000A    object](x: T): TObject {.magic: \"Fields\", noSideEffect.}"
  }, 
  {
    "name": "fields", 
    "type": "skIterator", 
    "description": "iterates over every field of <cite>x</cite> and <cite>y</cite>. Warning: This is really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.", 
    "code": "iterator fields*[S: tuple |\u000D\u000A    object, T: tuple |\u000D\u000A    object](x: S; y: T): tuple[a, b: expr] {.magic: \"Fields\", noSideEffect.}"
  }, 
  {
    "name": "fieldPairs", 
    "type": "skIterator", 
    "description": "iterates over every field of <cite>x</cite>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.", 
    "code": "iterator fieldPairs*[T: tuple |\u000D\u000A    object](x: T): TObject {.magic: \"FieldPairs\", noSideEffect.}"
  }, 
  {
    "name": "fieldPairs", 
    "type": "skIterator", 
    "description": "iterates over every field of <cite>x</cite> and <cite>y</cite>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.", 
    "code": "iterator fieldPairs*[S: tuple |\u000D\u000A    object, T: tuple |\u000D\u000A    object](x: S; y: T): tuple[a, b: expr] {.magic: \"FieldPairs\", noSideEffect.}"
  }, 
  {
    "name": "`==`", 
    "type": "skProc", 
    "description": "generic <tt class=\"docutils literal\"><span class=\"pre\">==</span></tt> operator for tuples that is lifted from the components of <cite>x</cite> and <cite>y</cite>.", 
    "code": "proc `==`*[T: tuple |\u000D\u000A    object](x, y: T): bool"
  }, 
  {
    "name": "`&lt;=`", 
    "type": "skProc", 
    "description": "generic <tt class=\"docutils literal\"><span class=\"pre\">&lt;=</span></tt> operator for tuples that is lifted from the components of <cite>x</cite> and <cite>y</cite>. This implementation uses <cite>cmp</cite>.", 
    "code": "proc `<=`*[T: tuple](x, y: T): bool"
  }, 
  {
    "name": "`&lt;`", 
    "type": "skProc", 
    "description": "generic <tt class=\"docutils literal\"><span class=\"pre\">&lt;</span></tt> operator for tuples that is lifted from the components of <cite>x</cite> and <cite>y</cite>. This implementation uses <cite>cmp</cite>.", 
    "code": "proc `<`*[T: tuple](x, y: T): bool"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "generic <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator for tuples that is lifted from the components of <cite>x</cite>. Example:<pre><span class=\"Operator\">$</span><span class=\"Punctation\">(</span><span class=\"DecNumber\">23</span><span class=\"Punctation\">,</span> <span class=\"DecNumber\">45</span><span class=\"Punctation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;(23, 45)&quot;</span>\u000D\u000A<span class=\"Operator\">$</span><span class=\"Punctation\">(</span><span class=\"Punctation\">)</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;()&quot;</span></pre>", 
    "code": "proc `$`*[T: tuple |\u000D\u000A    object](x: T): string"
  }, 
  {
    "name": "`$`", 
    "type": "skProc", 
    "description": "generic <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator for sets that is lifted from the components of <cite>x</cite>. Example:<pre><span class=\"Operator\">$</span><span class=\"Punctation\">{</span><span class=\"DecNumber\">23</span><span class=\"Punctation\">,</span> <span class=\"DecNumber\">45</span><span class=\"Punctation\">}</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;{23, 45}&quot;</span></pre>", 
    "code": "proc `$`*[T: set](x: T): string"
  }, 
  {
    "name": "GC_disable", 
    "type": "skProc", 
    "description": "disables the GC. If called n-times, n calls to <cite>GC_enable</cite> are needed to reactivate the GC. Note that in most circumstances one should only disable the mark and sweep phase with <cite>GC_disableMarkAndSweep</cite>.", 
    "code": "proc GC_disable*() {.rtl, inl.}"
  }, 
  {
    "name": "GC_enable", 
    "type": "skProc", 
    "description": "enables the GC again.", 
    "code": "proc GC_enable*() {.rtl, inl.}"
  }, 
  {
    "name": "GC_fullCollect", 
    "type": "skProc", 
    "description": "forces a full garbage collection pass. Ordinary code does not need to call this (and should not).", 
    "code": "proc GC_fullCollect*() {.rtl.}"
  }, 
  {
    "name": "TGC_Strategy", 
    "type": "skType", 
    "description": "the strategy the GC should use for the application", 
    "code": "TGC_Strategy* = enum \u000D\u000A  gcThroughput,               ## optimize for throughput\u000D\u000A  gcResponsiveness,           ## optimize for responsiveness (default)\u000D\u000A  gcOptimizeTime,             ## optimize for speed\u000D\u000A  gcOptimizeSpace             ## optimize for memory footprint"
  }, 
  {
    "name": "GC_setStrategy", 
    "type": "skProc", 
    "description": "tells the GC the desired strategy for the application. <strong>Deprecated</strong> since version 0.8.14. This has always been a nop.", 
    "code": "proc GC_setStrategy*(strategy: TGC_Strategy) {.rtl, deprecated.}"
  }, 
  {
    "name": "GC_enableMarkAndSweep", 
    "type": "skProc", 
    "code": "proc GC_enableMarkAndSweep*() {.rtl.}"
  }, 
  {
    "name": "GC_disableMarkAndSweep", 
    "type": "skProc", 
    "description": "the current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC.", 
    "code": "proc GC_disableMarkAndSweep*() {.rtl.}"
  }, 
  {
    "name": "GC_getStatistics", 
    "type": "skProc", 
    "description": "returns an informative string about the GC's activity. This may be useful for tweaking.", 
    "code": "proc GC_getStatistics*(): string {.rtl.}"
  }, 
  {
    "name": "GC_ref", 
    "type": "skProc", 
    "code": "proc GC_ref*[T](x: ref T) {.magic: \"GCref\".}"
  }, 
  {
    "name": "GC_ref", 
    "type": "skProc", 
    "code": "proc GC_ref*[T](x: seq[T]) {.magic: \"GCref\".}"
  }, 
  {
    "name": "GC_ref", 
    "type": "skProc", 
    "description": "marks the object <cite>x</cite> as referenced, so that it will not be freed until it is unmarked via <cite>GC_unref</cite>. If called n-times for the same object <cite>x</cite>, n calls to <cite>GC_unref</cite> are needed to unmark <cite>x</cite>. ", 
    "code": "proc GC_ref*(x: string) {.magic: \"GCref\".}"
  }, 
  {
    "name": "GC_unref", 
    "type": "skProc", 
    "code": "proc GC_unref*[T](x: ref T) {.magic: \"GCunref\".}"
  }, 
  {
    "name": "GC_unref", 
    "type": "skProc", 
    "code": "proc GC_unref*[T](x: seq[T]) {.magic: \"GCunref\".}"
  }, 
  {
    "name": "GC_unref", 
    "type": "skProc", 
    "description": "see the documentation of <cite>GC_ref</cite>.", 
    "code": "proc GC_unref*(x: string) {.magic: \"GCunref\".}"
  }, 
  {
    "name": "accumulateResult", 
    "type": "skTemplate", 
    "description": "helps to convert an iterator to a proc.", 
    "code": "template accumulateResult*(iter: expr)"
  }, 
  {
    "name": "outOfMemHook", 
    "type": "skVar", 
    "description": "set this variable to provide a procedure that should be called in case of an <span id=\"out-of-memory_745381972\">out of memory</span> event. The standard handler writes an error message and terminates the program. <cite>outOfMemHook</cite> can be used to raise an exception in case of OOM like so:<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">gOutOfMem</span><span class=\"Punctation\">:</span> <span class=\"Keyword\">ref</span> <span class=\"Identifier\">EOutOfMemory</span>\u000D\u000A<span class=\"Identifier\">new</span><span class=\"Punctation\">(</span><span class=\"Identifier\">gOutOfMem</span><span class=\"Punctation\">)</span> <span class=\"Comment\"># need to be allocated *before* OOM really happened!</span>\u000D\u000A<span class=\"Identifier\">gOutOfMem</span><span class=\"Operator\">.</span><span class=\"Identifier\">msg</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;out of memory&quot;</span>\u000D\u000A\u000D\u000A<span class=\"Keyword\">proc</span> <span class=\"Identifier\">handleOOM</span><span class=\"Punctation\">(</span><span class=\"Punctation\">)</span> <span class=\"Operator\">=</span>\u000D\u000A  <span class=\"Keyword\">raise</span> <span class=\"Identifier\">gOutOfMem</span>\u000D\u000A\u000D\u000A<span class=\"Identifier\">system</span><span class=\"Operator\">.</span><span class=\"Identifier\">outOfMemHook</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">handleOOM</span></pre><p>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</p>\u000D\u000A", 
    "code": "outOfMemHook*: proc () {.nimcall, tags: [].}"
  }, 
  {
    "name": "TFrame", 
    "type": "skType", 
    "description": "the frame itself", 
    "code": "TFrame* {.importc, nodecl, final.} = object \u000D\u000A  prev*: PFrame               ## previous frame; used for chaining the call stack\u000D\u000A  procname*: cstring          ## name of the proc that is currently executing\u000D\u000A  line*: int                  ## line number of the proc that is currently executing\u000D\u000A  filename*: cstring          ## filename of the proc that is currently executing\u000D\u000A  len*: int                   ## length of the inspectable slots\u000D\u000A  "
  }, 
  {
    "name": "add", 
    "type": "skProc", 
    "code": "proc add*(x: var string; y: cstring) {.noStackFrame.}"
  }, 
  {
    "name": "add", 
    "type": "skProc", 
    "code": "proc add*(x: var cstring; y: cstring) {.magic: \"AppendStrStr\".}"
  }, 
  {
    "name": "echo", 
    "type": "skProc", 
    "description": "special built-in that takes a variable number of arguments. Each argument is converted to a string via <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt>, so it works for user-defined types that have an overloaded <tt class=\"docutils literal\"><span class=\"pre\">$</span></tt> operator. It is roughly equivalent to <tt class=\"docutils literal\"><span class=\"pre\">writeln(stdout, x); flush(stdout)</span></tt>, but available for the JavaScript target too. Unlike other IO operations this is guaranteed to be thread-safe as <tt class=\"docutils literal\"><span class=\"pre\">echo</span></tt> is very often used for debugging convenience.", 
    "code": "proc echo*[T](x: varargs[T, `$`]) {.magic: \"Echo\", tags: [FWriteIO].}"
  }, 
  {
    "name": "debugEcho", 
    "type": "skProc", 
    "description": "Same as <tt class=\"docutils literal\"><span class=\"pre\">echo</span></tt>, but as a special semantic rule, <tt class=\"docutils literal\"><span class=\"pre\">debugEcho</span></tt> pretends to be free of side effects, so that it can be used for debugging routines marked as <tt class=\"docutils literal\"><span class=\"pre\">noSideEffect</span></tt>.", 
    "code": "proc debugEcho*[T](x: varargs[T, `$`]) {.magic: \"Echo\", noSideEffect, tags: [], \u000D\u000A    raises: [].}"
  }, 
  {
    "name": "newException", 
    "type": "skTemplate", 
    "description": "creates an exception object of type <tt class=\"docutils literal\"><span class=\"pre\">exceptn</span></tt> and sets its <tt class=\"docutils literal\"><span class=\"pre\">msg</span></tt> field to <cite>message</cite>. Returns the new exception object.", 
    "code": "template newException*(exceptn: typedesc; message: string): expr"
  }, 
  {
    "name": "getTypeInfo", 
    "type": "skProc", 
    "description": "get type information for <cite>x</cite>. Ordinary code should not use this, but the <cite>typeinfo</cite> module instead.", 
    "code": "proc getTypeInfo*[T](x: T): pointer {.magic: \"GetTypeInfo\".}"
  }, 
  {
    "name": "abs", 
    "type": "skProc", 
    "code": "proc abs*(x: int): int {.magic: \"AbsI\", noSideEffect.}"
  }, 
  {
    "name": "abs", 
    "type": "skProc", 
    "code": "proc abs*(x: int8): int8 {.magic: \"AbsI\", noSideEffect.}"
  }, 
  {
    "name": "abs", 
    "type": "skProc", 
    "code": "proc abs*(x: int16): int16 {.magic: \"AbsI\", noSideEffect.}"
  }, 
  {
    "name": "abs", 
    "type": "skProc", 
    "code": "proc abs*(x: int32): int32 {.magic: \"AbsI\", noSideEffect.}"
  }, 
  {
    "name": "abs", 
    "type": "skProc", 
    "description": "returns the absolute value of <cite>x</cite>. If <cite>x</cite> is <tt class=\"docutils literal\"><span class=\"pre\">low(x)</span></tt> (that is -MININT for its type), an overflow exception is thrown (if overflow checking is turned on).", 
    "code": "proc abs*(x: int64): int64 {.magic: \"AbsI64\", noSideEffect.}"
  }, 
  {
    "name": "TFileHandle", 
    "type": "skType", 
    "description": "type that represents an OS file handle; this is useful for low-level file access", 
    "code": "TFileHandle* = cint"
  }, 
  {
    "name": "stderr", 
    "type": "skVar", 
    "description": "<p>The standard error stream.</p>\u000D\u000A<p>Note: In my opinion, this should not be used -- the concept of a separate error stream is a design flaw of UNIX. A separate <em>message stream</em> is a good idea, but since it is named <tt class=\"docutils literal\"><span class=\"pre\">stderr</span></tt> there are few programs out there that distinguish properly between <tt class=\"docutils literal\"><span class=\"pre\">stdout</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">stderr</span></tt>. So, that's what you get if you don't name your variables appropriately. It also annoys people if redirection via <tt class=\"docutils literal\"><span class=\"pre\">&gt;output.txt</span></tt> does not work because the program writes to <tt class=\"docutils literal\"><span class=\"pre\">stderr</span></tt>.</p>\u000D\u000A", 
    "code": "stderr* {.importc: \"stderr\", header: \"<stdio.h>\".}: TFile"
  }, 
  {
    "name": "Open", 
    "type": "skProc", 
    "description": "<p>Opens a file named <cite>filename</cite> with given <cite>mode</cite>.</p>\u000D\u000A<p>Default mode is readonly. Returns true iff the file could be opened. This throws no exception if the file could not be opened.</p>\u000D\u000A", 
    "code": "proc Open*(f: var TFile; filename: string; mode: TFileMode = fmRead; \u000D\u000A           bufSize: int = - 1): Bool {.tags: [].}"
  }, 
  {
    "name": "Open", 
    "type": "skProc", 
    "description": "<p>Creates a <tt class=\"docutils literal\"><span class=\"pre\">TFile</span></tt> from a <cite>filehandle</cite> with given <cite>mode</cite>.</p>\u000D\u000A<p>Default mode is readonly. Returns true iff the file could be opened.</p>\u000D\u000A", 
    "code": "proc Open*(f: var TFile; filehandle: TFileHandle; mode: TFileMode = fmRead): Bool {.\u000D\u000A    tags: [].}"
  }, 
  {
    "name": "Open", 
    "type": "skProc", 
    "description": "<p>Opens a file named <cite>filename</cite> with given <cite>mode</cite>.</p>\u000D\u000A<p>Default mode is readonly. Raises an <tt class=\"docutils literal\"><span class=\"pre\">IO</span></tt> exception if the file could not be opened.</p>\u000D\u000A", 
    "code": "proc Open*(filename: string; mode: TFileMode = fmRead; bufSize: int = - 1): TFile"
  }, 
  {
    "name": "reopen", 
    "type": "skProc", 
    "description": "<p>reopens the file <cite>f</cite> with given <cite>filename</cite> and <cite>mode</cite>. This is often used to redirect the <cite>stdin</cite>, <cite>stdout</cite> or <cite>stderr</cite> file variables.</p>\u000D\u000A<p>Default mode is readonly. Returns true iff the file could be reopened.</p>\u000D\u000A", 
    "code": "proc reopen*(f: TFile; filename: string; mode: TFileMode = fmRead): bool {.\u000D\u000A    tags: [].}"
  }, 
  {
    "name": "Close", 
    "type": "skProc", 
    "description": "Closes the file.", 
    "code": "proc Close*(f: TFile) {.importc: \"fclose\", header: \"<stdio.h>\", tags: [].}"
  }, 
  {
    "name": "EndOfFile", 
    "type": "skProc", 
    "description": "Returns true iff <cite>f</cite> is at the end.", 
    "code": "proc EndOfFile*(f: TFile): Bool {.tags: [].}"
  }, 
  {
    "name": "readChar", 
    "type": "skProc", 
    "description": "Reads a single character from the stream <cite>f</cite>.", 
    "code": "proc readChar*(f: TFile): char {.importc: \"fgetc\", header: \"<stdio.h>\", \u000D\u000A                                 tags: [FReadIO].}"
  }, 
  {
    "name": "FlushFile", 
    "type": "skProc", 
    "description": "Flushes <cite>f</cite>'s buffer.", 
    "code": "proc FlushFile*(f: TFile) {.importc: \"fflush\", header: \"<stdio.h>\", \u000D\u000A                            tags: [FWriteIO].}"
  }, 
  {
    "name": "readAll", 
    "type": "skProc", 
    "description": "Reads all data from the stream <cite>file</cite>. Raises an IO exception in case of an error", 
    "code": "proc readAll*(file: TFile): TaintedString {.tags: [FReadIO].}"
  }, 
  {
    "name": "readFile", 
    "type": "skProc", 
    "description": "Opens a file named <cite>filename</cite> for reading. Then calls <cite>readAll</cite> and closes the file afterwards. Returns the string. Raises an IO exception in case of an error.", 
    "code": "proc readFile*(filename: string): TaintedString {.tags: [FReadIO].}"
  }, 
  {
    "name": "writeFile", 
    "type": "skProc", 
    "description": "Opens a file named <cite>filename</cite> for writing. Then writes the <cite>content</cite> completely to the file and closes the file afterwards. Raises an IO exception in case of an error.", 
    "code": "proc writeFile*(filename, content: string) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "code": "proc write*(f: TFile; r: float32) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "code": "proc write*(f: TFile; i: int) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "code": "proc write*(f: TFile; i: biggestInt) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "code": "proc write*(f: TFile; r: biggestFloat) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "code": "proc write*(f: TFile; s: string) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "code": "proc write*(f: TFile; b: Bool) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "code": "proc write*(f: TFile; c: char) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "code": "proc write*(f: TFile; c: cstring) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "write", 
    "type": "skProc", 
    "description": "Writes a value to the file <cite>f</cite>. May throw an IO exception.", 
    "code": "proc write*(f: TFile; a: varargs[string, `$`]) {.tags: [FWriteIO].}"
  }, 
  {
    "name": "readLine", 
    "type": "skProc", 
    "description": "reads a line of text from the file <cite>f</cite>. May throw an IO exception. A line of text may be delimited by <tt class=\"docutils literal\"><span class=\"pre\">CR</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">LF</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CRLF</span></tt>. The newline character(s) are not part of the returned string.", 
    "code": "proc readLine*(f: TFile): TaintedString {.tags: [FReadIO].}"
  }, 
  {
    "name": "readLine", 
    "type": "skProc", 
    "description": "reads a line of text from the file <cite>f</cite> into <cite>line</cite>. <cite>line</cite> must not be <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>! May throw an IO exception. A line of text may be delimited by <tt class=\"docutils literal\"><span class=\"pre\">CR</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">LF</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CRLF</span></tt>. The newline character(s) are not part of the returned string. Returns <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> if the end of the file has been reached, <tt class=\"docutils literal\"><span class=\"pre\">true</span></tt> otherwise. If <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> is returned <cite>line</cite> contains no new data.", 
    "code": "proc readLine*(f: TFile; line: var TaintedString): bool {.tags: [FReadIO].}"
  }, 
  {
    "name": "writeln", 
    "type": "skProc", 
    "description": "writes the values <cite>x</cite> to <cite>f</cite> and then writes &quot;n&quot;. May throw an IO exception.", 
    "code": "proc writeln*[Ty](f: TFile; x: varargs[Ty, `$`]) {.inline, tags: [FWriteIO].}"
  }, 
  {
    "name": "getFileSize", 
    "type": "skProc", 
    "description": "retrieves the file size (in bytes) of <cite>f</cite>.", 
    "code": "proc getFileSize*(f: TFile): int64 {.tags: [FReadIO].}"
  }, 
  {
    "name": "ReadBytes", 
    "type": "skProc", 
    "description": "reads <cite>len</cite> bytes into the buffer <cite>a</cite> starting at <tt class=\"docutils literal\"><span class=\"pre\">a[start]</span></tt>. Returns the actual number of bytes that have been read which may be less than <cite>len</cite> (if not as many bytes are remaining), but not greater.", 
    "code": "proc ReadBytes*(f: TFile; a: var openarray[int8]; start, len: int): int {.\u000D\u000A    tags: [FReadIO].}"
  }, 
  {
    "name": "ReadChars", 
    "type": "skProc", 
    "description": "reads <cite>len</cite> bytes into the buffer <cite>a</cite> starting at <tt class=\"docutils literal\"><span class=\"pre\">a[start]</span></tt>. Returns the actual number of bytes that have been read which may be less than <cite>len</cite> (if not as many bytes are remaining), but not greater.", 
    "code": "proc ReadChars*(f: TFile; a: var openarray[char]; start, len: int): int {.\u000D\u000A    tags: [FReadIO].}"
  }, 
  {
    "name": "readBuffer", 
    "type": "skProc", 
    "description": "reads <cite>len</cite> bytes into the buffer pointed to by <cite>buffer</cite>. Returns the actual number of bytes that have been read which may be less than <cite>len</cite> (if not as many bytes are remaining), but not greater.", 
    "code": "proc readBuffer*(f: TFile; buffer: pointer; len: int): int {.tags: [FReadIO].}"
  }, 
  {
    "name": "writeBytes", 
    "type": "skProc", 
    "description": "writes the bytes of <tt class=\"docutils literal\"><span class=\"pre\">a[start..start+len-1]</span></tt> to the file <cite>f</cite>. Returns the number of actual written bytes, which may be less than <cite>len</cite> in case of an error.", 
    "code": "proc writeBytes*(f: TFile; a: openarray[int8]; start, len: int): int {.\u000D\u000A    tags: [FWriteIO].}"
  }, 
  {
    "name": "writeChars", 
    "type": "skProc", 
    "description": "writes the bytes of <tt class=\"docutils literal\"><span class=\"pre\">a[start..start+len-1]</span></tt> to the file <cite>f</cite>. Returns the number of actual written bytes, which may be less than <cite>len</cite> in case of an error.", 
    "code": "proc writeChars*(f: tFile; a: openarray[char]; start, len: int): int {.\u000D\u000A    tags: [FWriteIO].}"
  }, 
  {
    "name": "writeBuffer", 
    "type": "skProc", 
    "description": "writes the bytes of buffer pointed to by the parameter <cite>buffer</cite> to the file <cite>f</cite>. Returns the number of actual written bytes, which may be less than <cite>len</cite> in case of an error.", 
    "code": "proc writeBuffer*(f: TFile; buffer: pointer; len: int): int {.tags: [FWriteIO].}"
  }, 
  {
    "name": "setFilePos", 
    "type": "skProc", 
    "description": "sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero.", 
    "code": "proc setFilePos*(f: TFile; pos: int64)"
  }, 
  {
    "name": "getFilePos", 
    "type": "skProc", 
    "description": "retrieves the current position of the file pointer that is used to read from the file <cite>f</cite>. The file's first byte has the index zero.", 
    "code": "proc getFilePos*(f: TFile): int64"
  }, 
  {
    "name": "fileHandle", 
    "type": "skProc", 
    "description": "returns the OS file handle of the file <tt class=\"docutils literal\"><span class=\"pre\">f</span></tt>. This is only useful for platform specific programming.", 
    "code": "proc fileHandle*(f: TFile): TFileHandle {.importc: \"fileno\", header: \"<stdio.h>\".}"
  }, 
  {
    "name": "cstringArrayToSeq", 
    "type": "skProc", 
    "description": "converts a <tt class=\"docutils literal\"><span class=\"pre\">cstringArray</span></tt> to a <tt class=\"docutils literal\"><span class=\"pre\">seq[string]</span></tt>. <cite>a</cite> is supposed to be of length <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt>.", 
    "code": "proc cstringArrayToSeq*(a: cstringArray; len: int): seq[string]"
  }, 
  {
    "name": "cstringArrayToSeq", 
    "type": "skProc", 
    "description": "converts a <tt class=\"docutils literal\"><span class=\"pre\">cstringArray</span></tt> to a <tt class=\"docutils literal\"><span class=\"pre\">seq[string]</span></tt>. <cite>a</cite> is supposed to be terminated by <tt class=\"docutils literal\"><span class=\"pre\">nil</span></tt>.", 
    "code": "proc cstringArrayToSeq*(a: cstringArray): seq[string]"
  }, 
  {
    "name": "allocCStringArray", 
    "type": "skProc", 
    "description": "creates a NULL terminated cstringArray from <cite>a</cite>. The result has to be freed with <cite>deallocCStringArray</cite> after it's not needed anymore.", 
    "code": "proc allocCStringArray*(a: openArray[string]): cstringArray"
  }, 
  {
    "name": "deallocCStringArray", 
    "type": "skProc", 
    "description": "frees a NULL terminated cstringArray.", 
    "code": "proc deallocCStringArray*(a: cstringArray)"
  }, 
  {
    "name": "atomicInc", 
    "type": "skProc", 
    "description": "atomic increment of <cite>memLoc</cite>. Returns the value after the operation.", 
    "code": "proc atomicInc*(memLoc: var int; x: int = 1): int {.inline, discardable.}"
  }, 
  {
    "name": "atomicDec", 
    "type": "skProc", 
    "description": "atomic decrement of <cite>memLoc</cite>. Returns the value after the operation.", 
    "code": "proc atomicDec*(memLoc: var int; x: int = 1): int {.inline, discardable.}"
  }, 
  {
    "name": "setControlCHook", 
    "type": "skProc", 
    "description": "allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.", 
    "code": "proc setControlCHook*(hook: proc () {.noconv.})"
  }, 
  {
    "name": "writeStackTrace", 
    "type": "skProc", 
    "description": "writes the current stack trace to <tt class=\"docutils literal\"><span class=\"pre\">stderr</span></tt>. This is only works for debug builds.", 
    "code": "proc writeStackTrace*() {.tags: [FWriteIO].}"
  }, 
  {
    "name": "getStackTrace", 
    "type": "skProc", 
    "description": "gets the current stack trace. This only works for debug builds.", 
    "code": "proc getStackTrace*(): string"
  }, 
  {
    "name": "getStackTrace", 
    "type": "skProc", 
    "description": "gets the stack trace associated with <cite>e</cite>, which is the stack that lead to the <tt class=\"docutils literal\"><span class=\"pre\">raise</span></tt> statement. This only works for debug builds.", 
    "code": "proc getStackTrace*(e: ref E_Base): string"
  }, 
  {
    "name": "lines", 
    "type": "skIterator", 
    "description": "Iterate over any line in the file named <cite>filename</cite>. If the file does not exist <cite>EIO</cite> is raised.", 
    "code": "iterator lines*(filename: string): TaintedString {.tags: [FReadIO].}"
  }, 
  {
    "name": "lines", 
    "type": "skIterator", 
    "description": "Iterate over any line in the file <cite>f</cite>.", 
    "code": "iterator lines*(f: TFile): TaintedString {.tags: [FReadIO].}"
  }, 
  {
    "name": "getCurrentException", 
    "type": "skProc", 
    "description": "retrieves the current exception; if there is none, nil is returned.", 
    "code": "proc getCurrentException*(): ref E_Base {.compilerRtl, inl.}"
  }, 
  {
    "name": "getCurrentExceptionMsg", 
    "type": "skProc", 
    "description": "retrieves the error message that was attached to the current exception; if there is none, &quot;&quot; is returned.", 
    "code": "proc getCurrentExceptionMsg*(): string {.inline.}"
  }, 
  {
    "name": "onRaise", 
    "type": "skProc", 
    "description": "can be used in a <tt class=\"docutils literal\"><span class=\"pre\">try</span></tt> statement to setup a Lisp-like <span id=\"condition-system_853186397\">condition system</span>: This prevents the 'raise' statement to raise an exception but instead calls <tt class=\"docutils literal\"><span class=\"pre\">action</span></tt>. If <tt class=\"docutils literal\"><span class=\"pre\">action</span></tt> returns false, the exception has been handled and does not propagate further through the call stack.", 
    "code": "proc onRaise*(action: proc (e: ref E_Base): bool {.closure.})"
  }, 
  {
    "name": "likely", 
    "type": "skProc", 
    "description": "can be used to mark a condition to be likely. This is a hint for the optimizer.", 
    "code": "proc likely*(val: bool): bool {.importc: \"likely\", nodecl, nosideeffect.}"
  }, 
  {
    "name": "unlikely", 
    "type": "skProc", 
    "description": "can be used to mark a condition to be unlikely. This is a hint for the optimizer.", 
    "code": "proc unlikely*(val: bool): bool {.importc: \"unlikely\", nodecl, nosideeffect.}"
  }, 
  {
    "name": "rawProc", 
    "type": "skProc", 
    "description": "retrieves the raw proc pointer of the closure <cite>x</cite>. This is useful for interfacing closures with C.", 
    "code": "proc rawProc*[T: proc](x: T): pointer {.noSideEffect, inline.}"
  }, 
  {
    "name": "rawEnv", 
    "type": "skProc", 
    "description": "retrieves the raw environment pointer of the closure <cite>x</cite>. This is useful for interfacing closures with C.", 
    "code": "proc rawEnv*[T: proc](x: T): pointer {.noSideEffect, inline.}"
  }, 
  {
    "name": "finished", 
    "type": "skProc", 
    "description": "can be used to determine if a first class iterator has finished.", 
    "code": "proc finished*[T: proc](x: T): bool {.noSideEffect, inline.}"
  }, 
  {
    "name": "quit", 
    "type": "skProc", 
    "description": "a shorthand for <tt class=\"docutils literal\"><span class=\"pre\">echo(errormsg); quit(errorcode)</span></tt>.", 
    "code": "proc quit*(errormsg: string; errorcode = QuitFailure) {.noReturn.}"
  }, 
  {
    "name": "`/`", 
    "type": "skProc", 
    "description": "integer division that results in a float.", 
    "code": "proc `/`*(x, y: int): float {.inline, noSideEffect.}"
  }, 
  {
    "name": "`-|`", 
    "type": "skTemplate", 
    "code": "template `-|`*(b, s: expr): expr"
  }, 
  {
    "name": "`[]`", 
    "type": "skProc", 
    "description": "slice operation for strings. Negative indexes are supported.", 
    "code": "proc `[]`*(s: string; x: TSlice[int]): string {.inline.}"
  }, 
  {
    "name": "`[]=`", 
    "type": "skProc", 
    "description": "slice assignment for strings. Negative indexes are supported. If <tt class=\"docutils literal\"><span class=\"pre\">b.len</span></tt> is not exactly the number of elements that are referred to by <cite>x</cite>, a <span id=\"splice_1406264289\">splice</span> is performed:<pre><span class=\"Keyword\">var</span> <span class=\"Identifier\">s</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;abcdef&quot;</span>\u000D\u000A<span class=\"Identifier\">s</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">1</span> <span class=\"Operator\">..</span> <span class=\"Operator\">-</span><span class=\"DecNumber\">2</span><span class=\"Punctation\">]</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;xyz&quot;</span>\u000D\u000A<span class=\"Identifier\">assert</span> <span class=\"Identifier\">s</span> <span class=\"Operator\">==</span> <span class=\"StringLit\">&quot;axyzf&quot;</span></pre>", 
    "code": "proc `[] =`*(s: var string; x: TSlice[int]; b: string)"
  }, 
  {
    "name": "`[]`", 
    "type": "skProc", 
    "description": "slice operation for arrays. Negative indexes are <strong>not</strong> supported because the array might have negative bounds.", 
    "code": "proc `[]`*[Idx, T](a: array[Idx, T]; x: TSlice[int]): seq[T]"
  }, 
  {
    "name": "`[]=`", 
    "type": "skProc", 
    "description": "slice assignment for arrays. Negative indexes are <strong>not</strong> supported because the array might have negative bounds.", 
    "code": "proc `[] =`*[Idx, T](a: var array[Idx, T]; x: TSlice[int]; b: openArray[T])"
  }, 
  {
    "name": "`[]`", 
    "type": "skProc", 
    "description": "slice operation for arrays. Negative indexes are <strong>not</strong> supported because the array might have negative bounds.", 
    "code": "proc `[]`*[Idx, T](a: array[Idx, T]; x: TSlice[Idx]): seq[T]"
  }, 
  {
    "name": "`[]=`", 
    "type": "skProc", 
    "description": "slice assignment for arrays. Negative indexes are <strong>not</strong> supported because the array might have negative bounds.", 
    "code": "proc `[] =`*[Idx, T](a: var array[Idx, T]; x: TSlice[Idx]; b: openArray[T])"
  }, 
  {
    "name": "`[]`", 
    "type": "skProc", 
    "description": "slice operation for sequences. Negative indexes are supported.", 
    "code": "proc `[]`*[T](s: seq[T]; x: TSlice[int]): seq[T]"
  }, 
  {
    "name": "`[]=`", 
    "type": "skProc", 
    "description": "slice assignment for sequences. Negative indexes are supported. If <tt class=\"docutils literal\"><span class=\"pre\">b.len</span></tt> is not exactly the number of elements that are referred to by <cite>x</cite>, a <span id=\"splice_1406264289\">splice</span> is performed. ", 
    "code": "proc `[] =`*[T](s: var seq[T]; x: TSlice[int]; b: openArray[T])"
  }, 
  {
    "name": "slurp", 
    "type": "skProc", 
    "description": "This is an alias for <tt class=\"docutils literal\"><span class=\"pre\">staticRead</span></tt>.", 
    "code": "proc slurp*(filename: string): string {.magic: \"Slurp\".}"
  }, 
  {
    "name": "staticRead", 
    "type": "skProc", 
    "description": "Compile-time <tt class=\"docutils literal\"><span class=\"pre\">readFile</span></tt> proc for easy <span id=\"resource_2039187725\">resource</span> embedding:<pre><span class=\"Keyword\">const</span> <span class=\"Identifier\">myResource</span> <span class=\"Operator\">=</span> <span class=\"RawData\">staticRead&quot;mydatafile.bin&quot;</span></pre><p><tt class=\"docutils literal\"><span class=\"pre\">slurp</span></tt> is an alias for <tt class=\"docutils literal\"><span class=\"pre\">staticRead</span></tt>.</p>\u000D\u000A", 
    "code": "proc staticRead*(filename: string): string {.magic: \"Slurp\".}"
  }, 
  {
    "name": "gorge", 
    "type": "skProc", 
    "description": "This is an alias for <tt class=\"docutils literal\"><span class=\"pre\">staticExec</span></tt>.", 
    "code": "proc gorge*(command: string; input = \"\"): string {.magic: \"StaticExec\".}"
  }, 
  {
    "name": "staticExec", 
    "type": "skProc", 
    "description": "Executes an external process at compile-time. if <cite>input</cite> is not an empty string, it will be passed as a standard input to the executed program.<pre><span class=\"Keyword\">const</span> <span class=\"Identifier\">buildInfo</span> <span class=\"Operator\">=</span> <span class=\"StringLit\">&quot;Revision &quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">staticExec</span><span class=\"Punctation\">(</span><span class=\"StringLit\">&quot;git rev-parse HEAD&quot;</span><span class=\"Punctation\">)</span> <span class=\"Operator\">&amp;</span>\u000D\u000A                  <span class=\"StringLit\">&quot;</span><span class=\"EscapeSequence\">\\n</span><span class=\"StringLit\">Compiled on &quot;</span> <span class=\"Operator\">&amp;</span> <span class=\"Identifier\">staticExec</span><span class=\"Punctation\">(</span><span class=\"StringLit\">&quot;uname -v&quot;</span><span class=\"Punctation\">)</span></pre><p><tt class=\"docutils literal\"><span class=\"pre\">gorge</span></tt> is an alias for <tt class=\"docutils literal\"><span class=\"pre\">staticExec</span></tt>. Note that you can use this proc inside a pragma like <a class=\"reference external\" href=\"nimrodc.html#passc-pragma\">passC</a> or <a class=\"reference external\" href=\"nimrodc.html#passl-pragma\">passL</a>.</p>\u000D\u000A", 
    "code": "proc staticExec*(command: string; input = \"\"): string {.magic: \"StaticExec\".}"
  }, 
  {
    "name": "`+=`", 
    "type": "skProc", 
    "description": "Increments an ordinal", 
    "code": "proc `+=`*[T: TOrdinal](x: var T; y: T) {.magic: \"Inc\", noSideEffect.}"
  }, 
  {
    "name": "`-=`", 
    "type": "skProc", 
    "description": "Decrements an ordinal", 
    "code": "proc `-=`*[T: TOrdinal](x: var T; y: T) {.magic: \"Dec\", noSideEffect.}"
  }, 
  {
    "name": "`*=`", 
    "type": "skProc", 
    "description": "Binary <cite>*=</cite> operator for ordinals", 
    "code": "proc `*=`*[T: TOrdinal](x: var T; y: T) {.inline, noSideEffect.}"
  }, 
  {
    "name": "`+=`", 
    "type": "skProc", 
    "description": "Increments in placee a floating point number", 
    "code": "proc `+=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}"
  }, 
  {
    "name": "`-=`", 
    "type": "skProc", 
    "description": "Decrements in place a floating point number", 
    "code": "proc `-=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}"
  }, 
  {
    "name": "`*=`", 
    "type": "skProc", 
    "description": "Multiplies in place a floating point number", 
    "code": "proc `*=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}"
  }, 
  {
    "name": "`/=`", 
    "type": "skProc", 
    "description": "Divides in place a floating point number", 
    "code": "proc `/=`*[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}"
  }, 
  {
    "name": "`&amp;=`", 
    "type": "skProc", 
    "code": "proc `&=`*(x: var string; y: string) {.magic: \"AppendStrStr\", noSideEffect.}"
  }, 
  {
    "name": "rand", 
    "type": "skProc", 
    "description": "compile-time <cite>random</cite> function. Useful for debugging.", 
    "code": "proc rand*(max: int): int {.magic: \"Rand\", sideEffect.}"
  }, 
  {
    "name": "astToStr", 
    "type": "skProc", 
    "description": "converts the AST of <cite>x</cite> into a string representation. This is very useful for debugging.", 
    "code": "proc astToStr*[T](x: T): string {.magic: \"AstToStr\", noSideEffect.}"
  }, 
  {
    "name": "instantiationInfo", 
    "type": "skProc", 
    "description": "<p>provides access to the compiler's instantiation stack line information.</p>\u000D\u000A<p>This proc is mostly useful for meta programming (eg. <tt class=\"docutils literal\"><span class=\"pre\">assert</span></tt> template) to retrieve information about the current filename and line number. Example:</p>\u000D\u000A<pre><span class=\"Keyword\">import</span> <span class=\"Identifier\">strutils</span>\u000D\u000A\u000D\u000A<span class=\"Keyword\">template</span> <span class=\"Identifier\">testException</span><span class=\"Punctation\">(</span><span class=\"Identifier\">exception</span><span class=\"Punctation\">,</span> <span class=\"Identifier\">code</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">expr</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">stmt</span> <span class=\"Operator\">=</span>\u000D\u000A  <span class=\"Keyword\">try</span><span class=\"Punctation\">:</span>\u000D\u000A    <span class=\"Keyword\">let</span> <span class=\"Identifier\">pos</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">instantiationInfo</span><span class=\"Punctation\">(</span><span class=\"Punctation\">)</span>\u000D\u000A    <span class=\"Keyword\">discard</span><span class=\"Punctation\">(</span><span class=\"Identifier\">code</span><span class=\"Punctation\">)</span>\u000D\u000A    <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;Test failure at $1:$2 with '$3'&quot;</span> <span class=\"Operator\">%</span> <span class=\"Punctation\">[</span><span class=\"Identifier\">pos</span><span class=\"Operator\">.</span><span class=\"Identifier\">filename</span><span class=\"Punctation\">,</span>\u000D\u000A      <span class=\"Operator\">$</span><span class=\"Identifier\">pos</span><span class=\"Operator\">.</span><span class=\"Identifier\">line</span><span class=\"Punctation\">,</span> <span class=\"Identifier\">astToStr</span><span class=\"Punctation\">(</span><span class=\"Identifier\">code</span><span class=\"Punctation\">)</span><span class=\"Punctation\">]</span>\u000D\u000A    <span class=\"Identifier\">assert</span> <span class=\"Identifier\">false</span><span class=\"Punctation\">,</span> <span class=\"StringLit\">&quot;A test expecting failure succeeded?&quot;</span>\u000D\u000A  <span class=\"Keyword\">except</span> <span class=\"Identifier\">exception</span><span class=\"Punctation\">:</span>\u000D\u000A    <span class=\"Keyword\">nil</span>\u000D\u000A\u000D\u000A<span class=\"Keyword\">proc</span> <span class=\"Identifier\">tester</span><span class=\"Punctation\">(</span><span class=\"Identifier\">pos</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">int</span> <span class=\"Operator\">=</span>\u000D\u000A  <span class=\"Keyword\">let</span>\u000D\u000A    <span class=\"Identifier\">a</span> <span class=\"Operator\">=</span> <span class=\"Operator\">@</span><span class=\"Punctation\">[</span><span class=\"DecNumber\">1</span><span class=\"Punctation\">,</span> <span class=\"DecNumber\">2</span><span class=\"Punctation\">,</span> <span class=\"DecNumber\">3</span><span class=\"Punctation\">]</span>\u000D\u000A  <span class=\"Identifier\">result</span> <span class=\"Operator\">=</span> <span class=\"Identifier\">a</span><span class=\"Punctation\">[</span><span class=\"Identifier\">pos</span><span class=\"Punctation\">]</span>\u000D\u000A\u000D\u000A<span class=\"Keyword\">when</span> <span class=\"Identifier\">isMainModule</span><span class=\"Punctation\">:</span>\u000D\u000A  <span class=\"Identifier\">testException</span><span class=\"Punctation\">(</span><span class=\"Identifier\">EInvalidIndex</span><span class=\"Punctation\">,</span> <span class=\"Identifier\">tester</span><span class=\"Punctation\">(</span><span class=\"DecNumber\">30</span><span class=\"Punctation\">)</span><span class=\"Punctation\">)</span>\u000D\u000A  <span class=\"Identifier\">testException</span><span class=\"Punctation\">(</span><span class=\"Identifier\">EInvalidIndex</span><span class=\"Punctation\">,</span> <span class=\"Identifier\">tester</span><span class=\"Punctation\">(</span><span class=\"DecNumber\">1</span><span class=\"Punctation\">)</span><span class=\"Punctation\">)</span>\u000D\u000A  <span class=\"Comment\"># --&gt; Test failure at example.nim:20 with 'tester(1)'</span></pre>", 
    "code": "proc instantiationInfo*(index = - 1; fullPaths = false): tuple[filename: string, \u000D\u000A    line: int] {.magic: \"InstantiationInfo\", noSideEffect.}"
  }, 
  {
    "name": "currentSourcePath", 
    "type": "skTemplate", 
    "description": "returns the full file-system path of the current source", 
    "code": "template currentSourcePath*(): string"
  }, 
  {
    "name": "raiseAssert", 
    "type": "skProc", 
    "code": "proc raiseAssert*(msg: string) {.noinline.}"
  }, 
  {
    "name": "assert", 
    "type": "skTemplate", 
    "description": "provides a means to implement <span id=\"programming-by-contracts_1723430192\">programming by contracts</span> in Nimrod. <tt class=\"docutils literal\"><span class=\"pre\">assert</span></tt> evaluates expression <tt class=\"docutils literal\"><span class=\"pre\">cond</span></tt> and if <tt class=\"docutils literal\"><span class=\"pre\">cond</span></tt> is false, it raises an <tt class=\"docutils literal\"><span class=\"pre\">EAssertionFailure</span></tt> exception. However, the compiler may not generate any code at all for <tt class=\"docutils literal\"><span class=\"pre\">assert</span></tt> if it is advised to do so. Use <tt class=\"docutils literal\"><span class=\"pre\">assert</span></tt> for debugging purposes only.", 
    "code": "template assert*(cond: bool; msg = \"\")"
  }, 
  {
    "name": "doAssert", 
    "type": "skTemplate", 
    "description": "same as <cite>assert</cite> but is always turned on and not affected by the <tt class=\"docutils literal\"><span class=\"pre\">--assertions</span></tt> command line switch.", 
    "code": "template doAssert*(cond: bool; msg = \"\")"
  }, 
  {
    "name": "onFailedAssert", 
    "type": "skTemplate", 
    "description": "Sets an assertion failure handler that will intercept any assert statements following <cite>onFailedAssert</cite> in the current lexical scope. Can be defined multiple times in a single function.<pre><span class=\"Keyword\">proc</span> <span class=\"Identifier\">example</span><span class=\"Punctation\">(</span><span class=\"Identifier\">x</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">int</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span> <span class=\"Identifier\">TErrorCode</span> <span class=\"Operator\">=</span>\u000D\u000A  <span class=\"Identifier\">onFailedAssert</span><span class=\"Punctation\">(</span><span class=\"Identifier\">msg</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span>\u000D\u000A    <span class=\"Identifier\">log</span> <span class=\"Identifier\">msg</span>\u000D\u000A    <span class=\"Keyword\">return</span> <span class=\"Identifier\">E_FAIL</span>\u000D\u000A  \u000D\u000A  <span class=\"Identifier\">assert</span><span class=\"Punctation\">(</span><span class=\"Operator\">...</span><span class=\"Punctation\">)</span>\u000D\u000A  \u000D\u000A  <span class=\"Identifier\">onFailedAssert</span><span class=\"Punctation\">(</span><span class=\"Identifier\">msg</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span>\u000D\u000A    <span class=\"Keyword\">raise</span> <span class=\"Identifier\">newException</span><span class=\"Punctation\">(</span><span class=\"Identifier\">EMyException</span><span class=\"Punctation\">,</span> <span class=\"Identifier\">msg</span><span class=\"Punctation\">)</span>\u000D\u000A  \u000D\u000A  <span class=\"Identifier\">assert</span><span class=\"Punctation\">(</span><span class=\"Operator\">...</span><span class=\"Punctation\">)</span></pre>", 
    "code": "template onFailedAssert*(msg: expr; code: stmt): stmt"
  }, 
  {
    "name": "shallow", 
    "type": "skProc", 
    "description": "marks a sequence <cite>s</cite> as <span id=\"shallow_1918244725\">shallow</span>. Subsequent assignments will not perform deep copies of <cite>s</cite>. This is only useful for optimization purposes.", 
    "code": "proc shallow*[T](s: var seq[T]) {.noSideEffect, inline.}"
  }, 
  {
    "name": "shallow", 
    "type": "skProc", 
    "description": "marks a string <cite>s</cite> as <span id=\"shallow_1918244725\">shallow</span>. Subsequent assignments will not perform deep copies of <cite>s</cite>. This is only useful for optimization purposes.", 
    "code": "proc shallow*(s: var string) {.noSideEffect, inline.}"
  }, 
  {
    "name": "PNimrodNode", 
    "type": "skType", 
    "description": "represents a Nimrod AST node. Macros operate on this type.", 
    "code": "PNimrodNode* {.magic: \"PNimrodNode\".} = ref TNimrodNode"
  }, 
  {
    "name": "insert", 
    "type": "skProc", 
    "description": "inserts <cite>item</cite> into <cite>x</cite> at position <cite>i</cite>.", 
    "code": "proc insert*(x: var string; item: string; i = 0) {.noSideEffect.}"
  }, 
  {
    "name": "compiles", 
    "type": "skProc", 
    "description": "Special compile-time procedure that checks whether <cite>x</cite> can be compiled without any semantic error. This can be used to check whether a type supports some operation:<pre><span class=\"Keyword\">when</span> <span class=\"Keyword\">not</span> <span class=\"Identifier\">compiles</span><span class=\"Punctation\">(</span><span class=\"DecNumber\">3</span> <span class=\"Operator\">+</span> <span class=\"DecNumber\">4</span><span class=\"Punctation\">)</span><span class=\"Punctation\">:</span>\u000D\u000A  <span class=\"Identifier\">echo</span> <span class=\"StringLit\">&quot;'+' for integers is available&quot;</span></pre>", 
    "code": "proc compiles*(x: expr): bool {.magic: \"Compiles\", noSideEffect.}"
  }, 
  {
    "name": "safeAdd", 
    "type": "skProc", 
    "code": "proc safeAdd*[T](x: var seq[T]; y: T) {.noSideEffect.}"
  }, 
  {
    "name": "safeAdd", 
    "type": "skProc", 
    "code": "proc safeAdd*(x: var string; y: char)"
  }, 
  {
    "name": "safeAdd", 
    "type": "skProc", 
    "code": "proc safeAdd*(x: var string; y: string)"
  }, 
  {
    "name": "locals", 
    "type": "skProc", 
    "description": "generates a tuple constructor expression listing all the local variables in the current scope. This is quite fast as it does not rely on any debug or runtime information. Note that in constrast to what the official signature says, the return type is not <tt class=\"docutils literal\"><span class=\"pre\">TObject</span></tt> but a tuple of a structure that depends on the current scope.", 
    "code": "proc locals*(): TObject {.magic: \"Locals\", noSideEffect.}"
  }
]