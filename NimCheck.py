import os.path
import re
import subprocess
import sublime
from sublime_plugin import ApplicationCommand, EventListener
from threading import Thread
from utils import (
    view_has_nim_syntax, send_self, busy_frames, FlagObject,
    loop_status_msg, write_output_view, show_output_view, get_output_view,
    format_tag, trim_region
)

"""
Contains commands related to checking Nim files for errors.
TODO:
 - Add syntax highlighting to NimCheckFile output (with option)
 - Add more advanced output view division (per-file)
 - Add more contextual information to NimCheckFile output (date,
    surrounding code, highlight point)
 - Simplify implementation (somehow)
"""
# Constants
error_regex_template = r"{0}\((\d+),\s*(\d+)\)\s*(\w*):\s*(.*)"
message_template = '({0}, {1}) {2}: {3}'.format
error_msg_format = '({0},{1}): {2}: {3}'.format

ERROR_REGION_TAG = 'NimCheckError'
WARN_REGION_TAG = 'NimCheckWarn'
ERROR_REGION_MARK = 'dot'
ERROR_REGION_STYLE = sublime.DRAW_OUTLINED


def debug(string):
    if False:
        print(string)


# Settings handlers
settings = None

# Settings for the 'check on save' feature
check_on_save_enabled = None
check_on_save_highlight_errors = None
check_on_save_highlight_warnings = None
check_on_save_list_errors = None
check_on_save_list_warnings = None

# Settings for the 'check current file' command
check_current_file_enabled = None
check_current_file_highlight_errors = None
check_current_file_highlight_warnings = None
check_current_file_list_errors = None
check_current_file_list_warnings = None

# Settings for the 'check external file' command
check_external_file_enabled = None
check_external_file_remember = None
check_external_file_output_clear = None
check_external_file_output_show = None
check_external_file_output_method = None
check_external_file_output_tag = None

compiler_executable = None


def update_settings():
    def load_key(key):
        globals()[key.replace('.', '_')] = settings.get(key)

    # Settings for checking a file on saving it
    load_key('check.on_save.enabled')
    load_key('check.on_save.highlight_errors')
    load_key('check.on_save.highlight_warnings')
    load_key('check.on_save.list_errors')
    load_key('check.on_save.list_warnings')

    # Settings for the 'check current file' command
    load_key('check.current_file.enabled')
    load_key('check.current_file.highlight_errors')
    load_key('check.current_file.highlight_warnings')
    load_key('check.current_file.list_errors')
    load_key('check.current_file.list_warnings')

    # Settings for the 'check external file' command
    load_key('check.external_file.enabled')
    load_key('check.external_file.remember')
    load_key('check.external_file.output.clear')
    load_key('check.external_file.output.method')
    load_key('check.external_file.output.show')
    load_key('check.external_file.output.tag')

    load_key('compiler.executable')


def load_settings():
    """ Load initial settings object, and manually run update_settings """
    global settings
    settings = sublime.load_settings('NimLime.sublime-settings')
    settings.clear_on_change('reload')
    settings.add_on_change('reload', update_settings)
    update_settings()


# Hack to lazily initialize ST2 settings
if int(sublime.version()) < 3000:
    sublime.set_timeout(load_settings, 1000)


class NimClearErrors(ApplicationCommand):

    """ Clears error and warning marks generated by the Nim checker. """

    def run(self):
        current_view = sublime.active_window().active_view()
        current_view.erase_regions(ERROR_REGION_TAG)
        current_view.erase_regions(WARN_REGION_TAG)

    def is_enabled(self):
        return True

    def is_visible(self):
        settings = sublime.active_window().active_view().settings()
        return ((check_current_file_enabled or check_on_save_enabled) and
                'nim' in settings.get('syntax', '').lower())

    def description(self):
        return self.__doc__


class NimCheckCurrentView(ApplicationCommand):

    """ Checks the current Nim file for errors. """

    def run(self, show_error_list=True):
        current_view = sublime.active_window().active_view()

        def callback(error_list):
            display_errors_inline(
                current_view,
                error_list,
                check_current_file_highlight_errors,
                check_current_file_list_errors,
                check_current_file_highlight_warnings,
                check_current_file_list_warnings,
            )

        # Save view text
        if current_view.is_dirty():
            current_view.run_command('save')

        Thread(
            target=run_nimcheck,
            args=(
                current_view.file_name(),
                callback
            )
        ).start()

    def is_enabled(self):
        return True

    def is_visible(self):
        return (check_current_file_enabled and view_has_nim_syntax())

    def description(self):
        return self.__doc__


class NimCheckOnSaveListener(EventListener):

    def on_post_save(self, view):
        debug('Entered NimCheckOnSaveListener.on_post_save')
        if (check_current_file_enabled and view_has_nim_syntax()):

            def callback(error_list):
                display_errors_inline(
                    view,
                    error_list,
                    check_on_save_highlight_errors,
                    check_on_save_list_errors,
                    check_on_save_highlight_warnings,
                    check_on_save_list_warnings,
                )

            Thread(
                target=run_nimcheck,
                args=(
                    view.file_name(),
                    callback
                )
            ).start()
        debug('Exiting NimCheckOnSaveListener.on_post_save')


class NimCheckFile(ApplicationCommand):

    """ Check an external nim file """
    last_entry = ''

    def run(self):
        window = sublime.active_window()

        @send_self
        def callback():
            this = yield

            # Retrieve user input
            if check_external_file_remember:
                initial_text = self.last_entry
            else:
                initial_text = ''

            path = yield window.show_input_panel(
                "File to check?", initial_text, this.send, None, None
            )
            self.last_entry = path

            # Run 'nim check' on the external file.
            if os.path.isfile(path):
                flag = FlagObject()
                frames = ['Checking external file' + f for f in busy_frames]
                loop_status_msg(frames, 0.25, flag)

                error_list = yield Thread(
                    target=run_nimcheck,
                    args=(path, this.send)
                ).start()

            else:
                sublime.error_message(
                    "File '{0}' does not exist, or isn't a file.".format(path)
                )
                yield

            # Prepare output
            output = '\n'.join(
                [error_msg_format(*error) for error in error_list]
            )

            # Stop the status loop
            yield setattr(flag, 'break_status_loop', this.next)
            sublime.status_message("External file checked.")

            # Print to the output view
            formatted_tag = format_tag(check_external_file_output_tag, window)
            output_view = get_output_view(
                formatted_tag,
                check_external_file_output_method,
                window
            )
            write_output_view(
                output_view, output,
                check_external_file_output_clear
            )
            if check_external_file_output_show:
                is_console = check_external_file_output_method == 'console'
                show_output_view(output_view, is_console)

            yield

        callback()

    def description(self):
        return self.__doc__


def goto_error(view, point_list, choice):
    if choice != -1:
        chosen_point = point_list[choice]
        view.show(chosen_point)


def run_nimcheck(file_path, output_callback):
    """
    Runs 'nim check' on the file specified by 'file_path', and returns
    a list of errors found to the output_callback.
    It's highly advised to run this in a thread!
    """
    debug("Running nim_check command")

    # Prepare the regex's
    file_name = re.escape(os.path.split(file_path)[1])
    error_regex = re.compile(
        error_regex_template.format(file_name),
        flags=re.MULTILINE | re.IGNORECASE
    )
    debug("Escaped file name: " + file_name)
    debug("Error Regex: " + error_regex.pattern)

    # Run nim check
    debug("Running 'nim check' process")

    nimcheck_process = subprocess.Popen(
        compiler_executable + " check \"{0}\"".format(file_path),
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        shell=True,
        bufsize=0
    )

    # Setup and start the polling procedure
    raw_output, err = nimcheck_process.communicate()
    output_buffer = raw_output.decode("UTF-8")
    debug("Output: " + output_buffer)
    debug("'nim check' is done.")
    debug("Return code: " + str(nimcheck_process.returncode))

    # Retrieve and convert the matches
    error_list = []
    for match in error_regex.finditer(output_buffer):
        line = int(match.group(1)) - 1
        column = int(match.group(2)) - 1
        kind = match.group(3)
        message = match.group(4)
        error_list.append((line, column, kind, message))

    # Sort the error list by line
    error_list.sort(key=lambda item: item[0])

    # Run the callback
    callback = lambda: output_callback(error_list)
    sublime.set_timeout(callback, 0)


def display_errors_inline(view, error_list,
                          highlight_errors=True, list_errors=True,
                          highlight_warnings=True, list_warnings=True):
    debug('In display_errors_inline')
    warn_region_list = []
    error_region_list = []
    message_list = []
    point_list = []

    for row, column, kind, message in error_list:
        # Prepare the error region for display
        debug("Error kind: " + kind)
        error_point = view.text_point(row, column)
        error_region = trim_region(view, view.line(error_point))
        if kind == 'Error':
            error_region_list.append(error_region)
        else:
            warn_region_list.append(error_region)

        # Prepare the error message for the quickbox
        quick_message = [
            message_template(row + 1, column, kind, message),
            view.substr(error_region)
        ]

        if ((kind == 'Error' and list_errors) or
                (kind != 'Error' and list_warnings)):
            message_list.append(quick_message)
            point_list.append(error_point)

    if highlight_errors:
        view.add_regions(
            ERROR_REGION_TAG,
            error_region_list,
            'invalid.illegal',
            ERROR_REGION_MARK,
            ERROR_REGION_STYLE
        )

    if highlight_warnings:
        view.add_regions(
            WARN_REGION_TAG,
            warn_region_list,
            'invalid.deprecated',
            ERROR_REGION_MARK,
            ERROR_REGION_STYLE
        )

    callback = lambda choice: goto_error(view, point_list, choice)
    if list_errors:
        sublime.active_window().show_quick_panel(message_list, callback)
