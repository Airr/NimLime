import os.path
import re
import subprocess
import sublime
from sublime_plugin import ApplicationCommand, EventListener
from threading import Thread

"""
Contains commands related to checking Nim files for errors.
TODO:
 - Add syntax highlighting to NimCheckFile output (with option)
 - Add 'remember last file' option to NimCheckFile
 - Deduplicate code in NimCheckOnSaveListener?
 - Add option to send NimCheckFile output to output panel or new view or shared
   view.
 - Simplify implementation (somehow)
"""
# Constants
error_regex_template = r"{0}\((\d+),\s*(\d+)\)\s*(\w*):\s*(.*)"
message_template = '({0}, {1}) {2}: {3}'.format
error_msg_format = '({0},{1}): {2}: {3}'.format

ERROR_REGION_TAG = 'NimCheckError'
WARN_REGION_TAG = 'NimCheckWarn'
ERROR_REGION_MARK = 'dot'
ERROR_REGION_STYLE = sublime.DRAW_OUTLINED


def debug(string):
    if False:
        print(string)


# Settings handlers
settings = None

check_on_save_enabled = None
check_on_save_highlight_errors = None
check_on_save_highlight_warnings = None
check_on_save_list_errors = None
check_on_save_list_warnings = None

# Settings for the 'check current file' command
check_current_file_enabled = None
check_current_file_highlight_errors = None
check_current_file_highlight_warnings = None
check_current_file_list_errors = None
check_current_file_list_warnings = None

# Settings for the 'check external file' command
check_external_file_enabled = None

compiler_executable = None


def update_settings():
    """ Update the currently loaded settings.
    Runs as a callback when settings are modified, and manually on startup.
    All settings variables should be initialized/modified here
    """
    debug('Entered update_settings')

    def load_key(key):
        globals()[key.replace('.', '_')] = settings.get(key)

    # Settings for checking a file on saving it
    load_key('check.on_save.enabled')
    load_key('check.on_save.highlight_errors')
    load_key('check.on_save.highlight_warnings')
    load_key('check.on_save.list_errors')
    load_key('check.on_save.list_warnings')

    # Settings for the 'check current file' command
    load_key('check.current_file.enabled')
    load_key('check.current_file.highlight_errors')
    load_key('check.current_file.highlight_warnings')
    load_key('check.current_file.list_errors')
    load_key('check.current_file.list_warnings')

    # Settings for the 'check external file' command
    load_key('check.external_file.enabled')

    load_key('compiler.executable')
    debug('Exiting update_settings')


def load_settings():
    """ Load initial settings object, and manually run update_settings """
    global settings
    debug('Entered load_settings')
    settings = sublime.load_settings('NimLime.sublime-settings')
    settings.clear_on_change('reload')
    settings.add_on_change('reload', update_settings)
    update_settings()
    debug('Exiting load_settings')


# Hack to lazily initialize ST2 settings
if int(sublime.version()) < 3000:
    sublime.set_timeout(load_settings, 1000)


class NimClearErrors(ApplicationCommand):

    """ Clears error and warning marks generated by the Nim checker. """

    def run(self):
        debug('Entered NimClearErrors.run')
        current_view = sublime.active_window().active_view()
        current_view.erase_regions(ERROR_REGION_TAG)
        current_view.erase_regions(WARN_REGION_TAG)
        debug('Exited NimClearErrors.run')

    def is_enabled(self):
        return True

    def is_visible(self):
        settings = sublime.active_window().active_view().settings()
        return ((check_current_file_enabled or check_on_save_enabled) and
                'nim' in settings.get('syntax', '').lower())

    def description(self):
        return self.__doc__


class NimCheckCurrentView(ApplicationCommand):

    """ Checks the current Nim file for errors. """

    def run(self, show_error_list=True):
        debug('Entered NimCheckCurrentView.run')
        current_view = sublime.active_window().active_view()

        def callback(error_list):
            display_errors_inline(
                current_view,
                error_list,
                check_current_file_highlight_errors,
                check_current_file_list_errors,
                check_current_file_highlight_warnings,
                check_current_file_list_warnings,
            )

        # Save view text
        if current_view.is_dirty():
            current_view.run_command('save')

        Thread(
            target=run_nimcheck,
            args=(
                current_view.file_name(),
                callback
            )
        ).start()
        debug('Exiting NimCheckCurrentView.run')

    def is_enabled(self):
        return True

    def is_visible(self):
        settings = sublime.active_window().active_view().settings()
        return (check_current_file_enabled and
                'nim' in settings.get('syntax', '').lower())

    def description(self):
        return self.__doc__


class NimCheckOnSaveListener(EventListener):

    def on_post_save(self, view):
        debug('Entered NimCheckOnSaveListener.on_post_save')
        if (check_current_file_enabled and
                'nim' in view.settings().get('syntax', '').lower()):

            def callback(error_list):
                display_errors_inline(
                    view,
                    error_list,
                    check_on_save_highlight_errors,
                    check_on_save_list_errors,
                    check_on_save_highlight_warnings,
                    check_on_save_list_warnings,
                )

            Thread(
                target=run_nimcheck,
                args=(
                    view.file_name(),
                    callback
                )
            ).start()
        debug('Exiting NimCheckOnSaveListener.on_post_save')


class NimCheckFile(ApplicationCommand):

    """ Check an external nim file """

    def run(self):
        debug('Entered NimCheckExternalFile.run')
        # Retrieve user input
        sublime.active_window().show_input_panel(
            "File to check?",
            "",
            self.check_external_file,
            None,
            None
        )
        debug('Exiting NimCheckExternalFile.run')

    def check_external_file(self, path):
        if os.path.isfile(path):
            Thread(
                target=run_nimcheck,
                args=(
                    path,
                    display_errors_in_new_view
                )
            ).start()
        else:
            sublime.error_message(
                "File '{0}' does not exist, or isn't a file.".format(path)
            )

    def description(self):
        return self.__doc__


def goto_error(view, point_list, choice):
    debug('Entered goto_error')
    if choice != -1:
        chosen_point = point_list[choice]
        view.show(chosen_point)
    debug('Exiting goto_error')


def trim_region(view, region):
    """
    Trim a region of whitespace.
    """
    text = view.substr(region)
    start = region.a + ((len(text) - 1) - (len(text.strip()) - 1))
    end = region.b - ((len(text) - 1) - (len(text.rstrip()) - 1))
    return sublime.Region(start, end)


def run_nimcheck(file_path, output_callback):
    """
    Runs 'nim check' on the file specified by 'file_path', and returns
    a list of errors found to the output_callback.
    It's highly advised to run this in a thread!
    """
    debug("Running nim_check command")

    # Prepare the regex's
    file_name = re.escape(os.path.split(file_path)[1])
    error_regex = re.compile(
        error_regex_template.format(file_name),
        flags=re.MULTILINE | re.IGNORECASE
    )
    debug("Escaped file name: " + file_name)
    debug("Error Regex: " + error_regex.pattern)

    # Run nim check
    debug("Running 'nim check' process")

    nimcheck_process = subprocess.Popen(
        compiler_executable + " check \"{0}\"".format(file_path),
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        shell=True,
        bufsize=0
    )

    # Setup and start the polling procedure
    raw_output, err = nimcheck_process.communicate()
    output_buffer = raw_output.decode("UTF-8")
    debug("Output: " + output_buffer)
    debug("'nim check' is done.")
    debug("Return code: " + str(nimcheck_process.returncode))

    # Retrieve and convert the matches
    error_list = []
    for match in error_regex.finditer(output_buffer):
        line = int(match.group(1)) - 1
        column = int(match.group(2)) - 1
        kind = match.group(3)
        message = match.group(4)
        error_list.append((line, column, kind, message))
    # Sort the error list by line
    error_list.sort(key=lambda item: item[0])

    # Run the callback
    callback = lambda: output_callback(error_list)
    sublime.set_timeout(callback, 0)


def display_errors_in_new_view(error_list,
                               show_errors=True, show_warnings=True):
    debug('In display_errors_in_new_view')
    # Open or retrieve display view
    output_view = None
    window = sublime.active_window()

    for view in window.views():
        if view.settings().get("nimcheck_error_output", False):
            output_view = view
            break
    else:
        output_view = window.new_file()
        output_view.set_name("NimCheck Output")
        output_view.set_scratch(True)
        output_view.settings().set("nimcheck_error_output", True)

    # Write errors to view

    output = '\n'.join(
        [error_msg_format(*error) for error in error_list]
    )

    edit = output_view.begin_edit()
    output_view.insert(edit, 0, output)
    output_view.end_edit(edit)


def display_errors_inline(view, error_list,
                          highlight_errors=True, list_errors=True,
                          highlight_warnings=True, list_warnings=True):
    debug('In display_errors_inline')
    warn_region_list = []
    error_region_list = []
    message_list = []
    point_list = []

    for row, column, kind, message in error_list:
        # Prepare the error region for display
        debug("Error kind: " + kind)
        error_point = view.text_point(row, column)
        error_region = trim_region(view, view.line(error_point))
        if kind == 'Error':
            error_region_list.append(error_region)
        else:
            warn_region_list.append(error_region)

        # Prepare the error message for the quickbox
        quick_message = [
            message_template(row + 1, column, kind, message),
            view.substr(error_region)
        ]

        if ((kind == 'Error' and list_errors) or
                (kind != 'Error' and list_warnings)):
            message_list.append(quick_message)
            point_list.append(error_point)

    if highlight_errors:
        view.add_regions(
            ERROR_REGION_TAG,
            error_region_list,
            'invalid.illegal',
            ERROR_REGION_MARK,
            ERROR_REGION_STYLE
        )

    if highlight_warnings:
        view.add_regions(
            WARN_REGION_TAG,
            warn_region_list,
            'invalid.deprecated',
            ERROR_REGION_MARK,
            ERROR_REGION_STYLE
        )

    callback = lambda choice: goto_error(view, point_list, choice)
    if list_errors:
        sublime.active_window().show_quick_panel(message_list, callback)
